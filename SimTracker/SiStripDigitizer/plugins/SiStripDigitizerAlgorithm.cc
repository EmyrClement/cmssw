// File: SiStripDigitizerAlgorithm.cc
// Description:  Steering class for digitization.
// Modified 15/May/2013 mark.grimes@bristol.ac.uk - Modified so that the digi-sim link has the correct
// index for the sim hits stored. It was previously always set to zero (I won't mention that it was
// me who originally wrote that).
// Modified on Feb 11, 2015: prolay.kumar.mal@cern.ch & Jean-Laurent.Agram@cern.ch
//                           Added/Modified the individual strip noise in zero suppression
//                           mode from the conditions DB; previously, the digitizer used to
//                           consider the noise value for individual strips inside a module from
//                           the central strip noise value.
//////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <vector>
#include <algorithm>
#include <iostream>
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "SiStripDigitizerAlgorithm.h"
#include "SimDataFormats/TrackingHit/interface/PSimHitContainer.h"
#include "SimDataFormats/TrackerDigiSimLink/interface/StripDigiSimLink.h"
#include "DataFormats/Common/interface/DetSetVector.h"
#include "DataFormats/GeometrySurface/interface/BoundSurface.h"
#include "SimGeneral/HepPDTRecord/interface/ParticleDataTable.h"
#include "CalibTracker/Records/interface/SiStripDependentRecords.h"
#include "CondFormats/SiStripObjects/interface/SiStripLorentzAngle.h"
#include "CondFormats/DataRecord/interface/SiStripCondDataRecords.h"
#include "CondFormats/SiStripObjects/interface/SiStripNoises.h"
#include "CondFormats/SiStripObjects/interface/SiStripThreshold.h"
#include "CondFormats/SiStripObjects/interface/SiStripPedestals.h"
#include "CondFormats/SiStripObjects/interface/SiStripBadStrip.h"
#include "CLHEP/Random/RandFlat.h"

#include <cstring>
#include <sstream>

#include <boost/algorithm/string.hpp>

SiStripDigitizerAlgorithm::SiStripDigitizerAlgorithm(const edm::ParameterSet& conf):
  lorentzAngleName(conf.getParameter<std::string>("LorentzAngle")),
  theThreshold(conf.getParameter<double>("NoiseSigmaThreshold")),
  cmnRMStib(conf.getParameter<double>("cmnRMStib")),
  cmnRMStob(conf.getParameter<double>("cmnRMStob")),
  cmnRMStid(conf.getParameter<double>("cmnRMStid")),
  cmnRMStec(conf.getParameter<double>("cmnRMStec")),
  APVSaturationProbScaling_(conf.getParameter<double>("APVSaturationProbScaling")),
  makeDigiSimLinks_(conf.getUntrackedParameter<bool>("makeDigiSimLinks", false)),
  peakMode(conf.getParameter<bool>("APVpeakmode")),
  noise(conf.getParameter<bool>("Noise")),
  RealPedestals(conf.getParameter<bool>("RealPedestals")), 
  SingleStripNoise(conf.getParameter<bool>("SingleStripNoise")),
  CommonModeNoise(conf.getParameter<bool>("CommonModeNoise")),
  BaselineShift(conf.getParameter<bool>("BaselineShift")),
  APVSaturationFromHIP(conf.getParameter<bool>("APVSaturationFromHIP")),
  theFedAlgo(conf.getParameter<int>("FedAlgorithm")),
  zeroSuppression(conf.getParameter<bool>("ZeroSuppression")),
  theElectronPerADC(conf.getParameter<double>( peakMode ? "electronPerAdcPeak" : "electronPerAdcDec" )),

  apv_minAmplitude(conf.getParameter<double>( "apv_minAmplitude" )), // 10000;
  apv_decayConstantInMicroS(conf.getParameter<double>( "apv_decayConstantInMicroS" )), // 200;
  apv_nPreviousInteractionsToSimulate(conf.getParameter<unsigned int>( "apv_nPreviousInteractionsToSimulate" )), //  = 100;
  apv_nBaselineToGenerate(conf.getParameter<unsigned int>( "apv_nBaselineToGenerate" )), // = 2000;
  apv_smallChangeThreshold(conf.getParameter<double>( "apv_smallChangeThreshold" )), // 0.001 
  apv_smallChangeN(conf.getParameter<unsigned int>( "apv_smallChangeN" )), //5

  apv_maxResponse(conf.getParameter<double>( "apv_maxResponse" )), // 729

  apv_rate(conf.getParameter<double>( "apv_rate" )), // 66.2
  apv_mVPerQ(conf.getParameter<double>( "apv_mVPerQ" )), // 5.5
  apv_fCPerElectron(conf.getParameter<double>( "apvfCPerElectron" )), // 1.602e-4

  theTOFCutForPeak(conf.getParameter<double>("TOFCutForPeak")),
  theTOFCutForDeconvolution(conf.getParameter<double>("TOFCutForDeconvolution")),
  tofCut(peakMode ? theTOFCutForPeak : theTOFCutForDeconvolution),
  cosmicShift(conf.getUntrackedParameter<double>("CosmicDelayShift")),
  inefficiency(conf.getParameter<double>("Inefficiency")),
  pedOffset((unsigned int)conf.getParameter<double>("PedestalsOffset")),
  PreMixing_(conf.getParameter<bool>("PreMixingMode")),
  theSiHitDigitizer(new SiHitDigitizer(conf)),
  theSiPileUpSignals(new SiPileUpSignals()),
  theSiNoiseAdder(new SiGaussianTailNoiseAdder(theThreshold)),
  theSiDigitalConverter(new SiTrivialDigitalConverter(theElectronPerADC, PreMixing_)),
  theSiZeroSuppress(new SiStripFedZeroSuppression(theFedAlgo)),
  APVProbabilityFile(conf.getParameter<edm::FileInPath>("APVProbabilityFile")),
  apvBaselineDistributions_tib_(4, std::vector<TH1F>() ),
  apvBaselineDistributions_tob_(6, std::vector<TH1F>() ),
  apvBaselineDistributions_tid_(3, std::vector<TH1F>() ),
  apvBaselineDistributions_tec_(7, std::vector<TH1F>() )
   {

  if (peakMode) {
    LogDebug("StripDigiInfo")<<"APVs running in peak mode (poor time resolution)";
  } else {
    LogDebug("StripDigiInfo")<<"APVs running in deconvolution mode (good time resolution)";
  };
  if(SingleStripNoise) LogDebug("SiStripDigitizerAlgorithm")<<" SingleStripNoise: ON";
  else LogDebug("SiStripDigitizerAlgorithm")<<" SingleStripNoise: OFF";
  if(CommonModeNoise) LogDebug("SiStripDigitizerAlgorithm")<<" CommonModeNoise: ON";
  else LogDebug("SiStripDigitizerAlgorithm")<<" CommonModeNoise: OFF";
  if(PreMixing_ && APVSaturationFromHIP) throw cms::Exception("PreMixing does not work with HIP loss simulation yet");
  if(APVSaturationFromHIP){  
    std::string line; 
    APVProbaFile.open((APVProbabilityFile.fullPath()).c_str());
    if (APVProbaFile.is_open()){
      while ( getline (APVProbaFile,line) ){
        std::vector<std::string> strs;
          boost::split(strs,line,boost::is_any_of(" "));
          if(strs.size()==2){
            mapOfAPVprobabilities[std::stoi(strs.at(0))]=std::stof(strs.at(1));
          }
      }
      APVProbaFile.close();
    }else throw cms::Exception("MissingInput")
         << "It seems that the APV probability list is missing\n";
  }

chargeDistributionParameters_ = {
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.143552341005, 8000.33272377, 2603.37947388, -0.649751665223, -0.000767880383269, 0.0801795499461, 11499.9233431, 2805.64579657, },  std::vector<float> {0.131851862311, 8000.04346039, 2798.83731876, -0.8414388793, -0.000683331480291, 0.0550759713847, 15712.3199169, 3326.57830456, },      std::vector<float> {0.102975601727, 8000.01140637, 3530.43835061, -0.927329225117, -0.000628272406234, 0.0825212395021, 10829.4126141, 3271.91004876, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.149207355982, 8001.02755969, 2659.63360926, -0.616541135726, -0.00076508969675, 0.152989651803, 10000.0000003, 2229.05049897, },    std::vector<float> {0.128556474205, 8000.00157467, 2969.70996466, -0.781381015787, -0.000675895077017, 0.0409554749202, 17332.5347151, 3912.03515189, },      std::vector<float> {0.116055826676, 8000.0003464, 3346.17642767, -0.884922257319, -0.00064461626506, 0.0566158944619, 14187.3383436, 3986.14458031, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.150925249016, 8000.61639742, 2546.46006066, -0.568477726908, -0.000755213274918, 0.182545889488, 10000.0000953, 1959.71616267, },   std::vector<float> {0.119434698413, 8000.0106869, 3245.60429052, -0.7635033787, -0.000663915418321, 0.067820307495, 12341.8308848, 3494.58221716, },      std::vector<float> {0.119582018609, 8000.00752821, 3242.72557832, -0.865092129654, -0.000623736624783, 0.0471264371378, 15783.4877596, 4247.32181188, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.15180343617, 8002.18146496, 2699.26966401, -0.623810660042, -0.000749963896938, 0.174061798177, 10000.0000002, 2084.80745289, },    std::vector<float> {0.127774488391, 8000.00246527, 3021.2237437, -0.867772348328, -0.000640324474856, 0.0477511369022, 15814.6484247, 3931.72464651, },       std::vector<float> {0.115981605594, 8000.00296914, 3388.38525711, -0.922635102942, -0.000624081971826, 0.0446512320286, 16599.5618559, 4513.71903784, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.151632162191, 8002.82035284, 2682.67315901, -0.647824717775, -0.000735733703906, 0.176105092774, 10000.0000003, 2104.4668958, },    std::vector<float> {0.126585075135, 8000.00189731, 3175.53834956, -0.766924496664, -0.000683255949633, 0.0572102257128, 14914.8662963, 3717.80299112, },      std::vector<float> {0.114912265875, 8000.00616042, 3477.59216163, -0.974950228089, -0.000595884135979, 0.0608559611572, 12981.4897735, 4252.49581946, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.148378550935, 8000.07691949, 2825.31620614, -0.612477719133, -0.00078886620971, 0.170386150476, 10395.9051314, 2136.8445019, },     std::vector<float> {0.129081945015, 8000.00897992, 3158.198593, -0.883912175401, -0.000638430829856, 0.0396520609976, 18810.9167545, 3891.08414245, },      std::vector<float> {0.111484808885, 8000.00457761, 3673.48982847, -1.03481465143, -0.00058343439917, 0.0498891179742, 15718.7680458, 4361.22135133, },    },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.159879847668, 8000.00127013, 2082.76428029, -1.00723513497, -0.000595688226395, 0.113239897555, 10000.0005332, 2269.38853643, },    std::vector<float> {0.139620687344, 8000.00852311, 2229.26727383, -0.871182214638, -0.000636282795021, 0.0587975150956, 12766.7186154, 3340.87481198, },      std::vector<float> {0.126866631277, 8000.18719704, 2939.32771578, -0.645333465583, -0.000755452409968, 0.0457947907176, 16358.5329907, 3367.67940268, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.161531849354, 8000.29987985, 2074.51086814, -0.924551122234, -0.000626697764333, 0.0752422834555, 10000.0000003, 2964.29745435, },  std::vector<float> {0.156558285608, 8000.00177659, 2213.16048209, -0.784878786942, -0.000669920457315, 0.0494327133575, 13732.8319565, 3656.62406767, },      std::vector<float> {0.137906492034, 8000.80054194, 2674.68947962, -0.722898363767, -0.000707121258374, 0.0762656609233, 12718.225679, 3161.07277513, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.16878327085, 8001.43538479, 2032.54798224, -0.894487216852, -0.000608939808895, 0.136500735671, 10000.0000001, 2099.22705801, },    std::vector<float> {0.161208467541, 8001.08177574, 2186.99209551, -0.799447248549, -0.000644939822287, 0.105150925241, 10000.0000223, 2656.9377515, },      std::vector<float> {0.140784537827, 8007.79682818, 2688.67523007, -0.7675209538, -0.000663991850941, 0.113470795125, 10097.9383277, 2811.93027939, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.169315114865, 8000.00093519, 2158.72661325, -0.881228710056, -0.000627487310578, 0.11561641249, 10000.0, 2465.6245582, },     std::vector<float> {0.149317563397, 8000.02945637, 2403.16859246, -0.798709674999, -0.000667825304397, 0.102364285322, 10000.0000029, 2875.90121009, },       std::vector<float> {0.141668514159, 8069.30592406, 2679.22971625, -0.82026697672, -0.0006702983608, 0.0430195851093, 16543.5751407, 3940.80063172, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.168727511951, 8000.0003657, 2137.12701297, -0.884836843037, -0.000622934019006, 0.0925180131507, 10000.0000085, 2814.01384163, },   std::vector<float> {0.156767930045, 8000.531622, 2316.27225294, -0.74889025097, -0.000684106000577, 0.0567319185668, 13175.2976358, 3613.86539467, },       std::vector<float> {0.134540176394, 8000.00484823, 2726.17261492, -0.830707985493, -0.000649425805925, 0.0781903841219, 11901.7751933, 3276.03375119, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.160920974687, 8001.76477427, 2238.9102015, -0.910067903034, -0.000640118957944, 0.113828950096, 10000.0, 2439.19330271, },    std::vector<float> {0.153554413787, 8000.00024667, 2369.10437445, -0.823814585657, -0.000667650312501, 0.0615831039582, 12909.7053072, 3488.46000744, },      std::vector<float> {0.125560116439, 8001.31631264, 3102.14707331, -0.862054589206, -0.000651052216067, 0.0484325718768, 16023.4766301, 3976.7665839, },     },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.149041553249, 8030.10353813, 3102.30485549, -0.687550374843, -0.000820534845085, 0.15252910466, 11541.7879399, 2170.85142077, },    std::vector<float> {0.126593391707, 8006.63842896, 3653.41699495, -0.451857554061, -0.000865970988651, 0.0969602542618, 11845.3396842, 3063.3076122, },       std::vector<float> {0.0966006116139, 8046.26802241, 5382.06423008, -0.858568301676, -0.000711996393624, 0.101440566678, 14400.0267864, 2745.07516063, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.145881707473, 8463.36747382, 2968.42399363, -0.604492233578, -0.000824874002581, 0.13718501818, 10000.0, 2505.67925362, },    std::vector<float> {0.136411249143, 8016.97856572, 3435.84430657, -0.611759816508, -0.000818009283151, 0.166478808205, 10611.6611941, 2350.01774915, },       std::vector<float> {0.108545236643, 8008.08659632, 4667.16103567, -0.834214878977, -0.000717692011949, 0.0514771867506, 18075.6292837, 3542.08362721, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.145868083153, 8000.23043367, 3226.65805011, -0.468858978855, -0.000859909677479, 0.179935990907, 10093.0465614, 2192.17586714, },   std::vector<float> {0.124774169073, 8000.27717274, 3634.92005545, -0.603880450708, -0.000788362857385, 0.0657015828327, 15415.6357015, 3134.94113796, },      std::vector<float> {0.107675420471, 8000.01907075, 4599.40789665, -0.723096595979, -0.000691732357096, 0.0682524640308, 14426.9343261, 3530.62545876, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.145358613, 8000.00011401, 3225.37719528, -0.575095121954, -0.000829006138969, 0.169154286384, 10048.7681555, 2298.01592173, },    std::vector<float> {0.115220719401, 10192.4529114, 3393.72433861, -0.895852431258, -0.000624707178764, 0.137414300871, 11155.1087867, 2626.911995, },       std::vector<float> {0.116676108672, 8000.30076635, 4273.79239234, -0.9010689254, -0.000687276838925, 0.114412680804, 10757.7747923, 3295.00245894, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.143526440397, 8021.27914039, 3250.8355814, -0.631062830105, -0.000810033755465, 0.129001594847, 10000.0000001, 2756.37081542, },    std::vector<float> {0.11976401689, 9236.78586893, 3512.36422471, -0.801216372982, -0.000677425249066, 0.145212424727, 10000.0000071, 2729.85764473, },      std::vector<float> {0.107720668207, 8001.94869265, 4581.20377932, -0.872017173276, -0.000682644371172, 0.0552452722463, 15754.3584106, 3939.23166162, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.131141031273, 8701.47899306, 3381.4590793, -0.611817518338, -0.000786524440025, 0.172075106649, 10646.0670042, 2178.95279813, },    std::vector<float> {0.133833861821, 8697.9201554, 3329.60323901, -0.820352149704, -0.000699172162914, 0.115549114792, 12844.3143423, 2510.47386651, },      std::vector<float> {0.101645452174, 10846.4518231, 3985.53775662, -1.11817464581, -0.000534567841535, 0.0472448653594, 19269.203456, 3452.07713936, },    },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.153166562501, 8284.3479346, 2576.33573901, -0.552466486059, -0.000875403300843, 0.158068575764, 12076.7776455, 1736.75525796, },    std::vector<float> {0.124486556277, 8084.27977535, 2929.55628096, -0.816911157077, -0.000718458095552, 0.0829304398507, 10000.0000049, 3358.32288531, },      std::vector<float> {0.109158285202, 8007.74241978, 4466.55855007, -0.864766292328, -0.000722366082224, 0.156706361855, 10885.9369617, 2299.50449773, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.147574236422, 8658.88545764, 2701.69534986, -0.837099400549, -0.000708085453029, 0.0939651847918, 10000.0000025, 3161.40590458, },  std::vector<float> {0.136978870832, 8000.01673906, 3084.59106696, -0.702660551977, -0.000799751685058, 0.15517752531, 10000.0000812, 2410.29774889, },      std::vector<float> {0.109294041936, 8003.82083663, 4155.47979199, -0.803803978453, -0.000714814066932, 0.125916091581, 10000.0100192, 2965.95267891, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.157650888685, 8017.90153988, 2841.23961889, -0.680737138954, -0.000781650775107, 0.143844935409, 10000.0000007, 2522.7020898, },    std::vector<float> {0.135533214643, 8589.1428114, 2982.24939387, -0.689757898457, -0.00071636764686, 0.0941115224018, 12399.3724482, 2794.45417723, },      std::vector<float> {0.127214723524, 8000.00588243, 3615.45904683, -0.715039934588, -0.000717759304255, 0.0878070804647, 13699.990582, 2990.12165249, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.157457707978, 8557.64352149, 2759.24513901, -0.828785010409, -0.000695051268904, 0.157856956005, 10000.0000468, 2304.61135153, },   std::vector<float> {0.136013511957, 8338.21011786, 3139.27921048, -0.709959889453, -0.000740435762305, 0.138577873475, 10000.0000006, 2782.52000623, },       std::vector<float> {0.113648070813, 9827.81392325, 3318.65798118, -0.899604631634, -0.000626052724135, 0.110618505398, 11766.2512342, 2850.47156668, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.148557252828, 8450.55434205, 2803.88830584, -0.740879821781, -0.000725592279543, 0.106830627025, 10000.0001009, 2984.60508162, },   std::vector<float> {0.137321159873, 8603.50068641, 3063.01773878, -0.754508389543, -0.00072311455132, 0.163164202889, 10170.4707241, 2387.14794424, },      std::vector<float> {0.12249370766, 8000.1133545, 3817.75484158, -0.73813111061, -0.000727741458714, 0.121011770306, 10974.486987, 2897.29259525, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.151528687015, 8821.02944767, 2812.00396858, -0.778412242044, -0.000706320321069, 0.162427291256, 10172.7799291, 2194.20737673, },   std::vector<float> {0.12581068928, 9181.73562085, 3355.63508904, -0.971872661824, -0.000615503526769, 0.128198916584, 10000.0000606, 2894.91771298, },      std::vector<float> {0.119793196711, 10142.8920613, 2810.6998759, -1.11384439899, -0.000516897827819, 0.0956189296545, 12829.1835723, 2874.0233824, },     },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.0765030128206, 14251.9677959, 4183.57441507, -1.50046833585, -0.000432405354686, 0.114998936561, 11027.3375569, 3333.02375961, },   std::vector<float> {0.0734209964417, 15026.0925331, 4434.95083567, -1.39339408583, -0.000421454901137, 0.131739914121, 11370.3458392, 3034.68355224, },       std::vector<float> {0.0684707223885, 19911.203402, 8960.26640196, -1.468282973, -0.000403705286194, 0.12642665136, 11561.2136158, 3222.86935482, },       std::vector<float> {0.0633064673485, 8008.11727846, 8999.65457124, -1.58680157926, -0.000417777172236, 0.0603644792904, 15922.8438062, 4740.62017223, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0857355028707, 13749.8779613, 4648.94012963, -1.30364295401, -0.000477364513593, 0.131720468372, 11350.5944425, 3085.81406639, },   std::vector<float> {0.0783738632442, 14953.4226233, 4986.22531594, -1.36304112993, -0.000431633535286, 0.131538136435, 11775.3250019, 3157.6983992, },      std::vector<float> {0.0707110447183, 8024.18006558, 8999.95824276, -1.35384303382, -0.000496478581314, 0.129582315668, 10798.7721621, 3352.02590433, },       std::vector<float> {0.0672182441513, 8007.8169946, 8999.5200516, -1.47593941246, -0.000452077031695, 0.0724037088152, 13628.6012309, 4859.54603895, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0878209640532, 13066.5572955, 4462.55619789, -1.29876961871, -0.000463142257989, 0.135967462933, 10546.3909999, 3030.49082998, },   std::vector<float> {0.0866921264119, 8162.92407643, 8994.10937856, -1.19807970279, -0.000558464889584, 0.140277502572, 11391.9646949, 2977.45086013, },       std::vector<float> {0.0757327333915, 8001.9206153, 8999.99992791, -1.41459669744, -0.000459681293536, 0.0844460718209, 14211.5897875, 3847.87637063, },       std::vector<float> {0.0621934688048, 8000.06645785, 8997.79635753, -1.4949314955, -0.000404417832819, 0.0642117496491, 14556.2207071, 4891.51117211, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0915415705646, 12510.4786706, 4516.98639138, -1.28458871414, -0.000488895581985, 0.131988465642, 10705.602677, 3203.24335133, },    std::vector<float> {0.0786117006803, 14901.6205924, 4868.88538876, -1.39788645025, -0.000421367875603, 0.130068287234, 11065.4602521, 3304.40032977, },       std::vector<float> {0.0760583498594, 8051.06356547, 8998.81691102, -1.39984141006, -0.000481235403394, 0.0964692649763, 12726.5027976, 3881.64004076, },      std::vector<float> {0.0665407495036, 8002.08846737, 8999.12011914, -1.53731368267, -0.000419856689646, 0.075874087217, 13995.8758021, 4598.10788366, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0894503512665, 13795.6733542, 4255.36236552, -1.37784908203, -0.000421082341049, 0.131723374112, 11157.2199849, 3182.90871442, },   std::vector<float> {0.0778957972857, 14761.8535919, 4999.58910482, -1.40404001471, -0.00040976025084, 0.130478635428, 10707.2459435, 3368.28199395, },      std::vector<float> {0.0787877465601, 8000.28627926, 8998.76124674, -1.45391606706, -0.000462961696014, 0.125418752424, 11162.4352446, 3625.10347476, },       std::vector<float> {0.0654676675036, 8000.70743986, 8999.69941561, -1.56958338701, -0.000402620393752, 0.0871201934133, 11993.8599769, 4528.0135166, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0940213384975, 13816.6745397, 4586.78278176, -1.35048346826, -0.000448710086618, 0.106214913181, 12615.4597787, 3483.56969333, },   std::vector<float> {0.0805414982414, 15938.9908699, 4512.07790683, -1.56117347841, -0.000353110216665, 0.122609771774, 11234.4205174, 3521.72344741, },       std::vector<float> {0.0720217240881, 17676.7637699, 5669.23679855, -1.57883652982, -0.000348733323207, 0.119534097315, 14237.7751189, 3183.92209712, },       std::vector<float> {0.0595752147576, 19037.6328912, 8910.39764672, -1.67023113113, -0.000343700016919, 0.074356283939, 15503.7112515, 4550.06040398, },     },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.0779414359253, 14438.6115367, 4878.2950686, -1.40914732872, -0.00046770985727, 0.111593042211, 10000.0001974, 3629.41198465, },     std::vector<float> {0.0782622828706, 13604.5125427, 3949.57153842, -1.42029748136, -0.000437676188951, 0.066107454622, 14753.1790717, 3882.72514721, },       std::vector<float> {0.0664941545913, 15546.5869977, 5024.73061221, -1.51213749555, -0.000396002919896, 0.1223577963, 11162.3109356, 3441.53967346, },       std::vector<float> {0.0703130928056, 8051.39139639, 8999.25340683, -1.48794513616, -0.000459333529639, 0.122789559965, 10308.3546147, 3737.09549423, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0872276433425, 13581.817121, 4353.42649497, -1.37049454152, -0.00046792216162, 0.124122247096, 10568.4916639, 3501.78230858, },     std::vector<float> {0.0797385139772, 14328.9927172, 4609.217551, -1.38631436428, -0.000433976520205, 0.128235838169, 11287.0125709, 3219.77617011, },       std::vector<float> {0.0713124827285, 16815.2907713, 8332.92713695, -1.39414315261, -0.000447138233462, 0.12786827978, 11216.5656637, 3300.09086444, },      std::vector<float> {0.0695194678572, 8021.73942319, 8998.6474653, -1.45213195367, -0.00046427308502, 0.0870343236813, 12832.8059464, 4317.06191205, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0879797884026, 13571.1924851, 4410.09562522, -1.41967091136, -0.000423515508195, 0.126008957555, 10000.0000013, 3310.74519294, },   std::vector<float> {0.0869479877207, 8050.55896643, 8999.99063032, -1.22691863334, -0.000550082440201, 0.136574864387, 10305.8823241, 3306.67801123, },       std::vector<float> {0.077984540864, 8028.74848357, 8999.94582034, -1.34646696404, -0.000495188915074, 0.0812660362818, 14471.611664, 3872.87165738, },      std::vector<float> {0.0661615516882, 8000.47372842, 8994.33378606, -1.54209225612, -0.00040858829573, 0.0782041774032, 13485.2788964, 4353.15323356, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0876474152958, 13266.8961984, 4166.04854204, -1.39172309839, -0.000442963912168, 0.125220030537, 10750.3337085, 3254.56596051, },   std::vector<float> {0.0788543680804, 15003.2514471, 4815.15952179, -1.43399145236, -0.000412977820238, 0.125957547078, 11060.6066428, 3346.23714734, },       std::vector<float> {0.0661885318508, 19426.7153278, 8988.53760262, -1.46951609434, -0.00040273495884, 0.0937416156643, 13651.5402595, 3685.75749123, },       std::vector<float> {0.0715832458896, 8030.42757027, 8998.25298546, -1.51015267485, -0.000445770329834, 0.110187484133, 11098.8919776, 4001.62273984, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0933585809398, 13525.601122, 4251.37971668, -1.37673623468, -0.000434175194949, 0.129885822347, 10023.8029977, 3429.37166416, },    std::vector<float> {0.0836776873241, 14119.1099575, 4643.23726589, -1.37724654781, -0.000427492786295, 0.129568830099, 10927.7830336, 3258.18895798, },       std::vector<float> {0.0695441693059, 17115.8688076, 8955.67492995, -1.43939296044, -0.000423884784928, 0.125790132904, 10869.067111, 3565.72910099, },      std::vector<float> {0.068716831842, 8003.01862436, 8997.34607175, -1.51764696543, -0.000426582396299, 0.106474281342, 11149.5515969, 4061.76335016, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0939408180862, 13125.0042764, 4490.48198729, -1.42689140445, -0.000448007592324, 0.121435075997, 10927.581864, 3453.18953553, },    std::vector<float> {0.0793611841846, 14800.1123684, 3996.01408132, -1.55840038445, -0.000366816650813, 0.117262139905, 10518.8242874, 3641.76766619, },       std::vector<float> {0.0670185772334, 15766.7213364, 4111.89958711, -1.62650344731, -0.000336033115925, 0.099830421214, 12371.106805, 3716.42583724, },      std::vector<float> {0.059309171559, 16954.8900063, 5051.45452725, -1.6910922082, -0.000308979909983, 0.0643439054539, 16151.1275078, 4612.96940519, },    },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.081148137402, 13330.1377323, 4272.70794327, -1.45199360118, -0.000452969960309, 0.119192927972, 11521.294737, 3412.61350546, },     std::vector<float> {0.0810284001644, 13503.5072864, 4339.09299867, -1.35721493267, -0.00045175763591, 0.0699402735121, 15983.4134279, 3780.41417409, },       std::vector<float> {0.076762264376, 12228.2594002, 4776.92125751, -1.61582563214, -0.000400231602022, 0.112215663371, 12709.6769125, 2993.96547823, },      std::vector<float> {0.0782980530713, 8003.97578082, 7874.80697809, -1.41674861568, -0.000508763592859, 0.126294933395, 11162.649306, 3432.49018931, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0880375480967, 13077.3865927, 4712.89159013, -1.42852983929, -0.000467615421763, 0.11774144291, 10312.1990806, 3550.58462679, },    std::vector<float> {0.0807875062988, 14004.3281644, 5783.59535448, -1.32159710827, -0.000483900940589, 0.128660425376, 10192.1386158, 3510.36048461, },       std::vector<float> {0.0680892200477, 16141.6892268, 4469.43205791, -1.56141381771, -0.000362029959172, 0.105101445974, 11364.0841269, 3640.06934952, },       std::vector<float> {0.0736910565826, 8118.2336957, 8999.57083838, -1.4528914159, -0.000471792630589, 0.123457513999, 10485.3328855, 3711.07612964, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0892876239568, 12681.6333701, 3706.56743678, -1.42551361963, -0.000442486683775, 0.121245629287, 10720.2318398, 3261.12835973, },   std::vector<float> {0.0877232568755, 14230.3398538, 4301.6063087, -1.35211630994, -0.000439908506061, 0.110010158747, 12521.7100853, 3424.06760558, },      std::vector<float> {0.0830577981728, 8000.15431544, 8998.70776035, -1.35763500298, -0.000498736406658, 0.130771160013, 10045.5943373, 3456.75315584, },       std::vector<float> {0.0728916606918, 8001.9490833, 8999.63691867, -1.45567045303, -0.000444380098444, 0.106644472097, 10979.4213721, 3975.64868057, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0973254990161, 12813.085391, 4008.50096229, -1.37423335252, -0.000447914195341, 0.127542600027, 10951.9360236, 3259.45897423, },    std::vector<float> {0.0811467291407, 14353.5389795, 4840.06028082, -1.42615626571, -0.000427489700803, 0.124732546507, 10000.0000002, 3549.42787915, },       std::vector<float> {0.0730525833956, 15813.3727441, 4695.64313004, -1.47412127063, -0.000374324776568, 0.126828401427, 10910.4179959, 3346.77680903, },       std::vector<float> {0.0746521234555, 8080.36735078, 8999.99673824, -1.51943949508, -0.000449368495888, 0.085238605014, 13613.8859983, 4129.37946797, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0994189521232, 12809.3706893, 4094.60800823, -1.34308254224, -0.000465732966244, 0.10399683687, 10000.0000145, 4134.07024651, },    std::vector<float> {0.085831151645, 14059.233597, 4121.77592676, -1.48286083495, -0.000398237002161, 0.124032145271, 11245.2572333, 3447.5601778, },      std::vector<float> {0.073258088359, 15824.9662527, 4628.2521654, -1.52058322935, -0.00036804853029, 0.119670644279, 11672.9558851, 3466.58008353, },      std::vector<float> {0.0766386245736, 8028.03772782, 8999.99771081, -1.50677520093, -0.000449496704911, 0.121280282714, 10387.0558557, 3844.8534385, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.111460078096, 13854.8143042, 3513.83417642, -1.51056017201, -0.000404199355173, 0.10641877842, 13163.2031818, 3400.95702816, },     std::vector<float> {0.0817580299288, 13712.0687617, 4360.41963684, -1.43297230836, -0.000408685077023, 0.125363326736, 10725.3131432, 3431.86498607, },       std::vector<float> {0.0701095854885, 17053.7635708, 4615.67852205, -1.70105403069, -0.000319787159654, 0.11333279188, 12809.869683, 3488.05608487, },       std::vector<float> {0.0596597910035, 17722.4567078, 5145.23040654, -1.75919583454, -0.000301129611311, 0.0851399893519, 14109.168946, 4230.6927353, },    },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.093652079687, 13218.4285861, 2461.6918554, -1.68118469818, -0.000351661198485, 0.0450105318343, 17866.2976578, 4795.14627382, },    std::vector<float> {0.0897590721065, 13549.4604943, 4275.491231, -1.40108942959, -0.000444721496939, 0.0511382963051, 18607.1071109, 3511.78404007, },      std::vector<float> {0.0779350912555, 16393.5897074, 3607.83606717, -1.66200910422, -0.000333944862372, 0.113534145027, 12926.8645952, 2831.69527536, },       std::vector<float> {0.0695262603437, 15642.0940258, 5721.86070519, -1.6123993999, -0.000396512436803, 0.110960021614, 12305.7708513, 3633.74955774, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0827680878541, 12953.2458224, 5120.91064142, -1.51129830722, -0.000465792329107, 0.0988991230923, 12996.4662849, 3874.8167079, },   std::vector<float> {0.0895833522996, 12863.16348, 3920.56199236, -1.39846029307, -0.00044314217025, 0.124541118735, 10965.4860353, 3218.36994172, },      std::vector<float> {0.0696527303114, 14933.6888003, 4148.88510483, -1.54563752762, -0.000371165734079, 0.110567680853, 12650.30268, 3391.99634551, },       std::vector<float> {0.0745091650826, 8082.81406934, 8994.24431025, -1.47495577178, -0.000460110871525, 0.0656462476874, 16077.9018256, 4218.56710559, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0873009292057, 13337.9933692, 3934.57735289, -1.43388501045, -0.000419126975973, 0.121523745349, 10646.4689564, 3385.2811481, },    std::vector<float> {0.0855140939664, 14418.4810667, 4033.86322825, -1.44379779453, -0.000400019700777, 0.108728034889, 12370.1571757, 3286.55648047, },       std::vector<float> {0.0799904128819, 8003.98207233, 8999.96814603, -1.39549339019, -0.000473574989084, 0.06066595884, 17953.912901, 3717.79658638, },       std::vector<float> {0.078280413164, 8010.46482498, 8999.96777193, -1.43046274837, -0.000468167549099, 0.0989569351092, 13358.2750816, 3820.50330962, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0943349579973, 12184.0126779, 3791.76730604, -1.40973043654, -0.000418789490306, 0.122202717551, 10000.0000081, 3666.82955724, },   std::vector<float> {0.0843804020781, 14352.2611972, 4183.34916984, -1.44833700862, -0.000399184966208, 0.127051650405, 11082.3064908, 3285.66002391, },       std::vector<float> {0.0769603853394, 14641.8934952, 4293.44491196, -1.55305935156, -0.000371875463945, 0.116675414128, 13290.3797992, 3201.67725026, },       std::vector<float> {0.0678936549857, 15339.4535295, 4681.614632, -1.55757829094, -0.000365814603197, 0.120987777534, 11310.7924762, 3532.23981018, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.109786738431, 8000.46177323, 6774.94795257, -1.2342638685, -0.00062575697278, 0.100643705875, 10000.0000092, 4195.13463774, },    std::vector<float> {0.0876734416909, 13816.6417373, 4257.70365257, -1.40240306832, -0.000422504715422, 0.126208975911, 10483.4058002, 3602.11573839, },       std::vector<float> {0.0781005226025, 13771.7879252, 4109.75775718, -1.53899065175, -0.000382162228369, 0.0972754820132, 13360.0556704, 3703.93428183, },      std::vector<float> {0.0620619274077, 16394.6838209, 5542.93556502, -1.55859527155, -0.000363494989758, 0.117173162144, 10000.0000036, 3880.86476484, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.0938316151144, 13600.1734465, 4023.97691759, -1.43420790359, -0.000428424136783, 0.0704614402187, 14703.1265656, 4100.44000767, },  std::vector<float> {0.0870988298677, 13473.2597822, 3713.5042853, -1.42964821618, -0.000420495144532, 0.122416213154, 10936.8443272, 3521.16439035, },      std::vector<float> {0.0755766804155, 13869.4839794, 6086.88251267, -1.56045700035, -0.000417654165729, 0.0976923159445, 13285.0309787, 3946.27626574, },      std::vector<float> {0.0628159089414, 19938.191399, 7029.47444099, -1.69296281437, -0.000329721613406, 0.103424075717, 13120.4356153, 3571.76404839, },    },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.107852970502, 10434.0730257, 2471.39890795, -1.69173449302, -0.000379335258787, 0.107853220528, 13767.2223195, 2353.92001862, },    std::vector<float> {0.134606662345, 8732.44223941, 2874.4957609, -1.04912339952, -0.000651580436794, 0.0429132381694, 17673.0963324, 3293.18081581, },      std::vector<float> {0.112044172446, 10109.8679872, 2204.57973199, -1.59253119975, -0.000405064003476, 0.0369669714958, 10000.0002486, 5120.7044766, },      std::vector<float> {0.123351383099, 10315.7442786, 2589.99437045, -1.36351081015, -0.000469408978098, 0.0340896848515, 19281.2952266, 3794.14529074, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.12871693518, 9225.94825449, 2361.98639969, -1.34018616409, -0.000513976005709, 0.0269250481253, 21109.5014805, 4143.97757256, },    std::vector<float> {0.140966682692, 9035.66279413, 2772.31642205, -1.06240902571, -0.000613933257907, 0.102449003139, 11424.6148709, 2985.77723227, },      std::vector<float> {0.11219157924, 10673.3320476, 2905.56248864, -1.39690352736, -0.00043732362952, 0.0424340323729, 19462.4927475, 3675.52052815, },       std::vector<float> {0.123975911971, 10093.5194749, 2889.00329223, -1.36342238284, -0.000470770939221, 0.0456211522833, 18428.6356501, 3857.9479052, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.158168971744, 8001.05028729, 2973.44835634, -0.320212923274, -0.000999899760686, 0.0886341161279, 12457.226782, 2861.60029132, },   std::vector<float> {0.156050155272, 8593.45964454, 2526.69085734, -0.902413541489, -0.000647655320003, 0.0551613939249, 15653.5346435, 3557.92379038, },      std::vector<float> {0.128753884683, 9161.8405762, 2689.25830101, -1.12439692295, -0.000529467288007, 0.0382375146935, 18628.5612902, 3768.52594904, },      std::vector<float> {0.125847849856, 10087.765345, 2893.42427814, -1.17207820421, -0.00051678781349, 0.0501571333326, 16149.3121837, 4092.64293335, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.152384218749, 8383.45550035, 2465.79957558, -1.04629641484, -0.000573787687024, 0.0537961974199, 16761.6912039, 3300.97062234, },   std::vector<float> {0.132780912977, 9732.74805805, 2516.0611289, -1.38665956069, -0.000461341581351, 0.0603708227134, 14630.6694345, 3352.3457993, },       std::vector<float> {0.139104138641, 8613.9891052, 2781.40357623, -1.08786800541, -0.000592740714723, 0.0393018165896, 17849.2421304, 4183.86475584, },      std::vector<float> {0.126491279603, 8281.21660472, 3584.26434294, -1.10196480654, -0.000638564121541, 0.0417078633153, 17806.6728618, 4240.14689218, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.13338327506, 9694.21593603, 2617.94471607, -1.39063284138, -0.000455548512522, 0.0389843861291, 19052.2780651, 3626.4360635, },     std::vector<float> {0.143242873215, 8775.05597809, 2565.90550325, -1.0075793726, -0.000618031080168, 0.0394884924745, 16469.9877165, 4405.98364328, },      std::vector<float> {0.134585692419, 9770.47041494, 2592.79850781, -1.26524610354, -0.000506686453578, 0.0481920205673, 16089.705408, 3644.0184902, },       std::vector<float> {0.113673318929, 10731.1419931, 2967.65069065, -1.36283180113, -0.000449341218463, 0.0438699569799, 17682.1204, 4325.04796686, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.138423154498, 8839.68769102, 2650.34092253, -1.2018803247, -0.000536935988684, 0.0523818139166, 16040.5112285, 3175.62838813, },    std::vector<float> {0.145914626881, 9854.84462974, 2511.89686541, -1.21537828549, -0.000499436669698, 0.0505832676748, 15660.4581326, 3785.12600124, },       std::vector<float> {0.130911198557, 9838.37029859, 2642.69040896, -1.32746180431, -0.000462049715478, 0.087986536554, 10627.8144228, 3785.04612345, },      std::vector<float> {0.110576335033, 10630.9842086, 2981.78086877, -1.31655671932, -0.000444741201503, 0.0388462510251, 20399.3591277, 4584.47854578, },     },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.126154381082, 9939.36699616, 2538.5363257, -1.38743674913, -0.000502469989457, 0.0876461437271, 10000.000006, 3518.50093777, },     std::vector<float> {0.148503706041, 8708.11764981, 2398.05713097, -0.993191740552, -0.000646226270504, 0.0393016370725, 17316.0822038, 3565.7220641, },       std::vector<float> {0.120151202033, 10782.6584128, 2316.55531534, -1.26467781114, -0.000488521095806, 0.0659812369476, 11358.0544085, 3433.56131074, },       std::vector<float> {0.123451668246, 11069.3853429, 2539.69629537, -1.41074496994, -0.00044839556885, 0.0419608710524, 19983.728417, 3245.66639282, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.127346228898, 9602.69709494, 2309.66963779, -1.48929873946, -0.000434860323543, 0.0357564232538, 19921.4400155, 4257.56618334, },   std::vector<float> {0.138678291684, 9361.63730745, 2538.85221987, -1.12139941886, -0.000580259243425, 0.0922681472969, 13358.0593409, 2758.36512799, },       std::vector<float> {0.13736824278, 10078.4247158, 2401.15642705, -1.28084774211, -0.000498279269181, 0.0678343426752, 14193.0879832, 3209.53430053, },      std::vector<float> {0.11296510138, 10745.8674753, 2669.85193008, -1.29157479508, -0.000463450163652, 0.0534198689895, 15866.3132925, 3714.41122322, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.139270837725, 8866.62016814, 2528.56390956, -1.20437312763, -0.00052691530648, 0.0692901231674, 14546.5764308, 3051.16722414, },    std::vector<float> {0.136910857094, 9367.19763584, 2546.16007821, -1.1262958606, -0.000553319578177, 0.0641216846721, 14597.781515, 3215.30444128, },       std::vector<float> {0.134867316568, 8015.5335556, 3348.07377453, -0.830484451876, -0.000724109186277, 0.072865654146, 12350.074655, 3371.74254914, },       std::vector<float> {0.119516410456, 10530.8179459, 2676.83985034, -1.27103600469, -0.00047154353585, 0.0440689365631, 19123.6871832, 3592.46685324, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.145527701558, 8763.04974995, 2536.84088085, -1.08723593629, -0.000585527920865, 0.0326619112575, 20162.2818336, 4218.81742742, },   std::vector<float> {0.143218068128, 9803.23493217, 2390.96623512, -1.24160855894, -0.000493733023021, 0.0550339844767, 15295.9953293, 3562.39821804, },       std::vector<float> {0.129382692319, 9644.45035894, 2699.46103314, -1.30829500958, -0.000488622589092, 0.0653789310658, 15206.8279694, 3317.75853922, },       std::vector<float> {0.123563899937, 9858.76977344, 2979.58116095, -1.12804166137, -0.000551272387883, 0.0575745359421, 16701.444897, 3467.52268408, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.140570400396, 8435.87198191, 2616.69519008, -1.16106432417, -0.000553273447526, 0.108881814073, 10000.2534602, 2850.38380218, },    std::vector<float> {0.13424659108, 9554.10179625, 2641.09579934, -1.23813195501, -0.000524459309287, 0.0435238828494, 16904.9433102, 4198.96033348, },      std::vector<float> {0.128756462086, 9956.67025284, 2488.78308228, -1.34919837045, -0.000473721921522, 0.104341401856, 10429.9629261, 3138.48316798, },      std::vector<float> {0.123430740974, 9753.80899531, 2794.82807229, -1.17743296767, -0.000509672181052, 0.0980322497904, 11162.7171315, 3132.48188781, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.133340612613, 9543.28090394, 2431.91451205, -1.39551269938, -0.000436876945272, 0.0403173981556, 22650.1582395, 3002.53707527, },   std::vector<float> {0.139897268097, 10370.2625144, 2418.27092657, -1.36998871883, -0.000437434925466, 0.115908717522, 10641.9804609, 2873.97862162, },      std::vector<float> {0.127526251374, 10360.8772318, 2423.99801721, -1.3611810555, -0.000428123607945, 0.0722718849402, 14392.8382576, 3196.77367307, },      std::vector<float> {0.117987174025, 9985.45000227, 2877.45052486, -1.20342532649, -0.000498652093858, 0.0414142731347, 18995.2960886, 3781.16848573, },     },
  },
};

occupancy_ = {
  std::vector< std::vector< float > >{
    std::vector< float > {0.00988993621679, 0.0097400483631, 0.00901957667151,    },    std::vector< float > {0.0225056742462, 0.0208329324456, 0.0214193752506,    },  std::vector< float > {0.0350604218561, 0.0318203880673, 0.0339170943859,    },    std::vector< float > {0.0497993800951, 0.0474108741397, 0.0473400973534,    },    std::vector< float > {0.063546069847, 0.0589343843006, 0.0598509165052,     },    std::vector< float > {0.0744393021588, 0.0671037946429, 0.0679221929506,    },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00685440806414, 0.00635421187789, 0.00616566051136,     },    std::vector< float > {0.0150039753648, 0.014794516533, 0.0146455802638,     },  std::vector< float > {0.0239820158883, 0.0224456787109, 0.0232680812027,    },    std::vector< float > {0.0331119151598, 0.0323904531973, 0.0344308564157,    },    std::vector< float > {0.0431291939763, 0.0416187427662, 0.0438182607323,    },    std::vector< float > {0.0525935598081, 0.048095703125, 0.0485691879735,     },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00581970214844, 0.00527072482639, 0.00512336282169,     },    std::vector< float > {0.0132728914909, 0.0130878083094, 0.0118544387044,    },  std::vector< float > {0.0195339747838, 0.0186008029514, 0.0166240018957,    },    std::vector< float > {0.0282641819545, 0.0274922688802, 0.0261401008157,    },    std::vector< float > {0.037545921689, 0.0351106770833, 0.0338608685662,     },    std::vector< float > {0.0417611258371, 0.0415690104167, 0.0395005170037,    },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00431290811567, 0.00404007523148, 0.00390446360518,     },    std::vector< float > {0.00974200254117, 0.00943480354007, 0.00807532590412,     },  std::vector< float > {0.0149180853545, 0.0136594419126, 0.0127995188643,    },    std::vector< float > {0.0219603581215, 0.0197663483796, 0.0189305747428,    },    std::vector< float > {0.0281483208955, 0.0263093171296, 0.0233049098069,    },    std::vector< float > {0.0323759619869, 0.0307481553819, 0.0287430926067,    },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00989815848214, 0.00916515531994, 0.00946626209077, 0.0101422991071,    },    std::vector< float > {0.0208036676416, 0.0212969599882, 0.022551538126, 0.0233575228987,    },    std::vector< float > {0.0324220203218, 0.032590230306, 0.0348227364676, 0.0340830485026,    },    std::vector< float > {0.0469040643601, 0.0470769973028, 0.0474729992094, 0.0492368425642,     },    std::vector< float > {0.062000093006, 0.0622709728423, 0.0642407614087, 0.0652018229167,    },    std::vector< float > {0.0680803571429, 0.0693126860119, 0.0716203962054, 0.0748683384487,     },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.007373046875, 0.00714772542318, 0.0074208577474, 0.00776875813802,    },    std::vector< float > {0.0161269615436, 0.0160706618737, 0.0165780604571, 0.0170989639458,     },    std::vector< float > {0.025234858195, 0.0246636072795, 0.024974822998, 0.0262851715088,     },    std::vector< float > {0.0361417134603, 0.0354220072428, 0.0358715057373, 0.0383475621541,     },    std::vector< float > {0.0470662434896, 0.0467125786675, 0.0479695638021, 0.049355061849,    },    std::vector< float > {0.0513559977214, 0.0522727966309, 0.0545247395833, 0.0564626057943,     },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00523817274306, 0.00476255063657, 0.00523998119213, 0.00543619791667,     },    std::vector< float > {0.0117449413314, 0.0116002654055, 0.0118628023228, 0.0121914411718,     },    std::vector< float > {0.0181443956163, 0.0183354130498, 0.0181670012297, 0.0184608742043,     },    std::vector< float > {0.0243021647135, 0.0253928855613, 0.0255827727141, 0.0276251898872,     },    std::vector< float > {0.0334285783179, 0.0341423128858, 0.0340940875772, 0.0351068190586,     },    std::vector< float > {0.0406268084491, 0.037281177662, 0.0391438802083, 0.0426070601852,    },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00336181640625, 0.00374552408854, 0.00420328776042, 0.00433797200521,     },    std::vector< float > {0.00874416307471, 0.00864145563937, 0.00892544450431, 0.00929109419899,     },    std::vector< float > {0.0128194173177, 0.0131164550781, 0.013389078776, 0.0141581217448,    },    std::vector< float > {0.0183797200521, 0.0185440063477, 0.020160929362, 0.020127360026,     },    std::vector< float > {0.0233637152778, 0.0243234592014, 0.0271929253472, 0.0265755208333,     },    std::vector< float > {0.0292643229167, 0.0281697591146, 0.030126953125, 0.0298116048177,    },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00213561395202, 0.00267962831439, 0.00247395833333, 0.00261131826073,     },    std::vector< float > {0.00558181491641, 0.00567093347266, 0.00588148456548, 0.00621397841562,     },    std::vector< float > {0.00844874526515, 0.00869442718198, 0.00937228732639, 0.00947863646228,     },    std::vector< float > {0.0114955709438, 0.0125106657394, 0.0127520320391, 0.0134308169586,     },    std::vector< float > {0.0156453861532, 0.0164634627525, 0.018138415404, 0.0174923058712,    },    std::vector< float > {0.0171884864268, 0.0176607382418, 0.0179233743687, 0.0189948804451,     },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00154842342342, 0.00180840019707, 0.0018651463964, 0.00169886683559,    },    std::vector< float > {0.00366931451926, 0.00386013707673, 0.00396449790308, 0.00403700440742,     },    std::vector< float > {0.00582363369229, 0.00624235685881, 0.0062195374085, 0.00635782877604,    },    std::vector< float > {0.0085608679969, 0.0089551221143, 0.00951158678209, 0.00933288024352,     },    std::vector< float > {0.0112501173048, 0.01166918872, 0.0126478040541, 0.0123076201201,     },    std::vector< float > {0.0125611451295, 0.0130285314611, 0.0142767278998, 0.0146539361627,     },  },
};

  chargeDistributionParameters_puBinEdges_ = { 0, 10, 20, 30, 40, 50 };
  chargeDistributionParameters_zBinEdges_ = { 0, 25, 50, 75 };




  apvBaselineDistributions_tib_ = {};
  for ( auto zBin:chargeDistributionParameters_zBinEdges_ ) {
    apvBaselineDistributions_tib_[0].push_back( TH1F( TString( "TIB1_" + std::to_string( zBin ) ).Data() , TString( "TIB1_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tib_[1].push_back( TH1F( TString( "TIB2_" + std::to_string( zBin ) ).Data() , TString( "TIB2_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tib_[2].push_back( TH1F( TString( "TIB3_" + std::to_string( zBin ) ).Data() , TString( "TIB3_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tib_[3].push_back( TH1F( TString( "TIB4_" + std::to_string( zBin ) ).Data() , TString( "TIB4_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );


    apvBaselineDistributions_tob_[0].push_back( TH1F( TString( "TOB1_" + std::to_string( zBin ) ).Data() , TString( "TOB1_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tob_[1].push_back( TH1F( TString( "TOB2_" + std::to_string( zBin ) ).Data() , TString( "TOB2_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tob_[2].push_back( TH1F( TString( "TOB3_" + std::to_string( zBin ) ).Data() , TString( "TOB3_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tob_[3].push_back( TH1F( TString( "TOB4_" + std::to_string( zBin ) ).Data() , TString( "TOB4_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tob_[4].push_back( TH1F( TString( "TOB5_" + std::to_string( zBin ) ).Data() , TString( "TOB5_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tob_[5].push_back( TH1F( TString( "TOB6_" + std::to_string( zBin ) ).Data() , TString( "TOB6_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );


    apvBaselineDistributions_tid_[0].push_back( TH1F( TString( "TID1_" + std::to_string( zBin ) ).Data() , TString( "TID1_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tid_[1].push_back( TH1F( TString( "TID2_" + std::to_string( zBin ) ).Data() , TString( "TID2_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tid_[2].push_back( TH1F( TString( "TID3_" + std::to_string( zBin ) ).Data() , TString( "TID3_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );

    apvBaselineDistributions_tec_[0].push_back( TH1F( TString( "TEC1_" + std::to_string( zBin ) ).Data() , TString( "TEC1_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[1].push_back( TH1F( TString( "TEC2_" + std::to_string( zBin ) ).Data() , TString( "TEC2_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[2].push_back( TH1F( TString( "TEC3_" + std::to_string( zBin ) ).Data() , TString( "TEC3_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[3].push_back( TH1F( TString( "TEC4_" + std::to_string( zBin ) ).Data() , TString( "TEC4_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[4].push_back( TH1F( TString( "TEC5_" + std::to_string( zBin ) ).Data() , TString( "TEC5_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[5].push_back( TH1F( TString( "TEC6_" + std::to_string( zBin ) ).Data() , TString( "TEC6_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[6].push_back( TH1F( TString( "TEC7_" + std::to_string( zBin ) ).Data() , TString( "TEC7_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
  }

}

SiStripDigitizerAlgorithm::~SiStripDigitizerAlgorithm(){
}

void
SiStripDigitizerAlgorithm::initializeDetUnit(StripGeomDetUnit const * det, const edm::EventSetup& iSetup){
  edm::ESHandle<SiStripBadStrip> deadChannelHandle;
  iSetup.get<SiStripBadChannelRcd>().get(deadChannelHandle);

  unsigned int detId = det->geographicalId().rawId();
  int numStrips = (det->specificTopology()).nstrips();  

  SiStripBadStrip::Range detBadStripRange = deadChannelHandle->getRange(detId);
  //storing the bad strip of the the module. the module is not removed but just signal put to 0
  std::vector<bool>& badChannels = allBadChannels[detId];
  badChannels.clear();
  badChannels.insert(badChannels.begin(), numStrips, false);
  for(SiStripBadStrip::ContainerIterator it = detBadStripRange.first; it != detBadStripRange.second; ++it) {
    SiStripBadStrip::data fs = deadChannelHandle->decode(*it);
    for(int strip = fs.firstStrip; strip < fs.firstStrip + fs.range; ++strip) {
		badChannels[strip] = true;
	}
  }
  firstChannelsWithSignal[detId] = numStrips;
  lastChannelsWithSignal[detId]= 0;

  //  if(APVSaturationFromHIP){
  //  std::bitset<6> &bs=SiStripTrackerAffectedAPVMap[detId];
  //  if(bs.any())theAffectedAPVvector.push_back(std::make_pair(detId,bs));
  //}
}

void
SiStripDigitizerAlgorithm::initializeEvent(const edm::EventSetup& iSetup) {
  theSiPileUpSignals->reset();
  // This should be clear by after all calls to digitize(), but I might as well make sure
  associationInfoForDetId_.clear();

  APVSaturationProb_ = APVSaturationProbScaling_;  // reset probability
  SiStripTrackerAffectedAPVMap.clear();
  FirstLumiCalc_ = true;
  FirstDigitize_ = true;

  //get gain noise pedestal lorentzAngle from ES handle
  edm::ESHandle<ParticleDataTable> pdt;
  iSetup.getData(pdt);
  setParticleDataTable(&*pdt);
  iSetup.get<SiStripLorentzAngleSimRcd>().get(lorentzAngleName,lorentzAngleHandle);

  for ( unsigned int i = 0; i < apvBaselineDistributions_tib_.size(); ++ i ) {
    for ( auto hist:apvBaselineDistributions_tib_[i] ) hist.Reset();
  }
  for ( unsigned int i = 0; i < apvBaselineDistributions_tob_.size(); ++ i ) {
    for ( auto hist:apvBaselineDistributions_tob_[i] ) hist.Reset();
  }
  for ( unsigned int i = 0; i < apvBaselineDistributions_tid_.size(); ++ i ) {
    for ( auto hist:apvBaselineDistributions_tid_[i] ) hist.Reset();
  }
  for ( unsigned int i = 0; i < apvBaselineDistributions_tec_.size(); ++ i ) {
    for ( auto hist:apvBaselineDistributions_tec_[i] ) hist.Reset();
  }

}

//  Run the algorithm for a given module
//  ------------------------------------

void
SiStripDigitizerAlgorithm::accumulateSimHits(std::vector<PSimHit>::const_iterator inputBegin,
                                             std::vector<PSimHit>::const_iterator inputEnd,
                                             size_t inputBeginGlobalIndex,
					     unsigned int tofBin,
                                             const StripGeomDetUnit* det,
                                             const GlobalVector& bfield,
					     const TrackerTopology *tTopo,
                                             CLHEP::HepRandomEngine* engine) {
  // produce SignalPoints for all SimHits in detector
  unsigned int detID = det->geographicalId().rawId();
  int numStrips = (det->specificTopology()).nstrips();  

  size_t thisFirstChannelWithSignal = numStrips;
  size_t thisLastChannelWithSignal = 0;

  float langle = (lorentzAngleHandle.isValid()) ? lorentzAngleHandle->getLorentzAngle(detID) : 0.;

  std::vector<float> locAmpl(numStrips, 0.);

  // Loop over hits

  uint32_t detId = det->geographicalId().rawId();
  // First: loop on the SimHits
  if(CLHEP::RandFlat::shoot(engine) > inefficiency) {
    AssociationInfoForChannel* pDetIDAssociationInfo; // I only need this if makeDigiSimLinks_ is true...
    if( makeDigiSimLinks_ ) pDetIDAssociationInfo=&(associationInfoForDetId_[detId]); // ...so only search the map if that is the case
    std::vector<float> previousLocalAmplitude; // Only used if makeDigiSimLinks_ is true. Needed to work out the change in amplitude.

    size_t simHitGlobalIndex=inputBeginGlobalIndex; // This needs to stored to create the digi-sim link later
    for (std::vector<PSimHit>::const_iterator simHitIter = inputBegin; simHitIter != inputEnd; ++simHitIter, ++simHitGlobalIndex ) {
      // skip hits not in this detector.
      if((*simHitIter).detUnitId() != detId) {
        continue;
      }
      // check TOF
      if (std::fabs(simHitIter->tof() - cosmicShift - det->surface().toGlobal(simHitIter->localPosition()).mag()/30.) < tofCut && simHitIter->energyLoss()>0) {
        if( makeDigiSimLinks_ ) previousLocalAmplitude=locAmpl; // Not needed except to make the sim link association.
        size_t localFirstChannel = numStrips;
        size_t localLastChannel  = 0;
        // process the hit
        theSiHitDigitizer->processHit(&*simHitIter, *det, bfield, langle, locAmpl, localFirstChannel, localLastChannel, tTopo, engine);
 
        if(thisFirstChannelWithSignal > localFirstChannel) thisFirstChannelWithSignal = localFirstChannel;
        if(thisLastChannelWithSignal < localLastChannel) thisLastChannelWithSignal = localLastChannel;

        if( makeDigiSimLinks_ ) { // No need to do any of this if truth association was turned off in the configuration
          for( size_t stripIndex=0; stripIndex<locAmpl.size(); ++stripIndex ) {
            // Work out the amplitude from this SimHit from the difference of what it was before and what it is now
            float signalFromThisSimHit=locAmpl[stripIndex]-previousLocalAmplitude[stripIndex];
            if( signalFromThisSimHit!=0 ) { // If this SimHit had any contribution I need to record it.
              auto& associationVector=(*pDetIDAssociationInfo)[stripIndex];
              bool addNewEntry=true;
              // Make sure the hit isn't in already. I've seen this a few times, it always seems to happen in pairs so I think
              // it's something to do with the stereo strips.
              for( auto& associationInfo : associationVector ) {
                if( associationInfo.trackID==simHitIter->trackId() && associationInfo.eventID==simHitIter->eventId() ) {
                  // The hit is already in, so add this second contribution and move on
                  associationInfo.contributionToADC+=signalFromThisSimHit;
                  addNewEntry=false;
                  break;
                }
              } // end of loop over associationVector
              // If the hit wasn't already in create a new association info structure.
              if( addNewEntry ) associationVector.push_back( AssociationInfo{ simHitIter->trackId(), simHitIter->eventId(), signalFromThisSimHit, simHitGlobalIndex, tofBin } );
            } // end of "if( signalFromThisSimHit!=0 )"
          } // end of loop over locAmpl strips
        } // end of "if( makeDigiSimLinks_ )"
      } // end of TOF check
    } // end for
  }
  theSiPileUpSignals->add(detID, locAmpl, thisFirstChannelWithSignal, thisLastChannelWithSignal);

  if(firstChannelsWithSignal[detID] > thisFirstChannelWithSignal) firstChannelsWithSignal[detID] = thisFirstChannelWithSignal;
  if(lastChannelsWithSignal[detID] < thisLastChannelWithSignal) lastChannelsWithSignal[detID] = thisLastChannelWithSignal;
}

//============================================================================                
void SiStripDigitizerAlgorithm::calculateInstlumiScale(PileupMixingContent* puInfo){
  //Instlumi scalefactor calculating for dynamic inefficiency                                 

  if (puInfo && FirstLumiCalc_) {

    const std::vector<int>& bunchCrossing = puInfo->getMix_bunchCrossing();
    const std::vector<float>& TrueInteractionList = puInfo->getMix_TrueInteractions();
    const int bunchSpacing = puInfo->getMix_bunchSpacing();                                 

    double RevFreq = 11245.;
    double minBXsec = 70.0E-27;  // use 70mb as an approximation
    double Bunch = 2100.;        // 2016 value
    if (bunchSpacing == 50) Bunch = Bunch/2.;

    int pui = 0, p = 0;
    std::vector<int>::const_iterator pu;
    std::vector<int>::const_iterator pu0 = bunchCrossing.end();

    for (pu=bunchCrossing.begin(); pu!=bunchCrossing.end(); ++pu) {
      if (*pu==0) {
        pu0 = pu;
        p = pui;
      }
      pui++;
    }
    if (pu0!=bunchCrossing.end()) {  // found the in-time interaction
      double Tintr = TrueInteractionList.at(p);
      double instLumi = Bunch*Tintr*RevFreq/minBXsec;
      APVSaturationProb_ = instLumi/6.0E33;      
    }
    FirstLumiCalc_ = false;
  }
}

//============================================================================                

void SiStripDigitizerAlgorithm::calculateAPVBaselines(
              TrackingGeometry::DetContainer detUnits,
              const TrackerTopology *tTopo,
              PileupMixingContent* puInfo
              ) {

    // Mostly duplicating code in calculateInstlumiScale
    // Move to a function
    const std::vector<int>& bunchCrossing = puInfo->getMix_bunchCrossing();
    const std::vector<float>& TrueInteractionList = puInfo->getMix_TrueInteractions();
    int pui = 0, p = 0;
    std::vector<int>::const_iterator pu;
    std::vector<int>::const_iterator pu0 = bunchCrossing.end();
    for (pu=bunchCrossing.begin(); pu!=bunchCrossing.end(); ++pu) {
      if (*pu==0) {
        pu0 = pu;
        p = pui;
      }
      pui++;
    }
    unsigned int nTrueInteractions = 0;
    if (pu0!=bunchCrossing.end()) {  // found the in-time interaction
      nTrueInteractions = TrueInteractionList.at(p);
    }

    unsigned int chargeDistributionParameters_puBin = nTrueInteractions / 10;
    // std::cout << "PU bin : " << nTrueInteractions << " " << nTrueInteractions / 10 << " " << chargeDistributionParameters_puBin << std::endl;

    std::vector<unsigned int> nStrips_tib = { 0, 0, 0, 0 };
    std::vector<unsigned int> nStrips_tob = { 0, 0, 0, 0, 0, 0 };
    std::vector<unsigned int> nStrips_tid = { 0, 0, 0 };
    std::vector<unsigned int> nStrips_tec = { 0, 0, 0, 0, 0, 0, 0 };

    std::vector<unsigned int> nStripsNonZero_tib = { 0, 0, 0, 0 };
    std::vector<unsigned int> nStripsNonZero_tob = { 0, 0, 0, 0, 0, 0 };
    std::vector<unsigned int> nStripsNonZero_tid = { 0, 0, 0 };
    std::vector<unsigned int> nStripsNonZero_tec = { 0, 0, 0, 0, 0, 0, 0 };

    std::vector<float> occupancy_tib = { 0, 0, 0, 0 };
    std::vector<float> occupancy_tob = { 0, 0, 0, 0, 0, 0 };
    std::vector<float> occupancy_tid = { 0, 0, 0 };
    std::vector<float> occupancy_tec = { 0, 0, 0, 0, 0, 0, 0 };

    TH1F h_charge_tib = TH1F("h_charge_tib", "h_charge_tib", 60, 0, 60000);
    TH1F h_charge_tob = TH1F("h_charge_tob", "h_charge_tob", 60, 0, 60000);
    TH1F h_charge_tid = TH1F("h_charge_tid", "h_charge_tid", 60, 0, 60000);
    TH1F h_charge_tec = TH1F("h_charge_tec", "h_charge_tec", 60, 0, 60000);

    // Loop all strips and store total number of strips in each layer, strips with charge/amplitude > X, and store distribution of charges
    for(TrackingGeometry::DetContainer::const_iterator iu = detUnits.begin(); iu != detUnits.end(); iu ++){

      auto sgd = dynamic_cast<StripGeomDetUnit const*>((*iu));
      if (sgd != 0){

        DetId detId( sgd->geographicalId() );
        uint32_t SubDet = detId.subdetId();
        int layer = -1;

        if(SubDet==3) {
          layer = tTopo->tibLayer(detId);
          nStrips_tib[layer-1] += sgd->specificTopology().nstrips();
        }
        else if(SubDet==4){
          layer = tTopo->tidRing(detId);
          nStrips_tid[layer-1] += sgd->specificTopology().nstrips();
        } 
        else if(SubDet==5){
          layer = tTopo->tobLayer(detId);
          nStrips_tob[layer-1] += sgd->specificTopology().nstrips();
        } 
        else if(SubDet==6){
          layer = tTopo->tecRing(detId);
          nStrips_tec[layer-1] += sgd->specificTopology().nstrips();
        }


        const SiPileUpSignals::SignalMapType* theSignal(theSiPileUpSignals->getSignal(sgd->geographicalId().rawId()));  

        if(theSignal) {
          for(const auto& amp : *theSignal) {
            if ( amp.second > apv_minAmplitude ) {
              if(SubDet==3) {
                ++nStripsNonZero_tib[layer-1];
                h_charge_tib.Fill( amp.second );
              }
              else if(SubDet==4){
                ++nStripsNonZero_tid[layer-1];
                h_charge_tid.Fill( amp.second );
              } 
              else if(SubDet==5){
                ++nStripsNonZero_tob[layer-1];
                h_charge_tob.Fill( amp.second );
                // std::cout << "TOB charge : " << amp.second << std::endl;
                // if ( amp.second > 30000 ) std::cout << "----> BIG CHARGE" << std::endl;
              } 
              else if(SubDet==6){
                ++nStripsNonZero_tec[layer-1];
                h_charge_tec.Fill( amp.second );
              } 
            }
          }
        }
      }
    }

    // std::cout << "TOB charge info" << std::endl;
    // std::cout << "Entries, mean, max value : " << h_charge_tob.GetEntries() << " " << h_charge_tob.GetMean() << " " << h_charge_tob.GetBinCenter( h_charge_tob.FindLastBinAbove(0) ) << std::endl;


    // For each layer in each subdetctor, calculate the occupancy
    // Also generate a distribution of the APV baseline for each layer
    // std::cout << "Generating APV baselines for TIB" << std::endl;
    for ( unsigned int i = 0; i < nStrips_tib.size(); ++i ) {
      // std::cout << i << std::endl;
      occupancy_tib[i] = float(nStripsNonZero_tib[i]) / float(nStrips_tib[i]);
      std::vector< float > occupanciesVsZ = occupancy_[i][chargeDistributionParameters_puBin];
      // We know which layer we are in
      // Can get the function describing the charge deposited for different bins in z for the number PU in this event
      // std::vector< std::vector< float > > chargeDistributionParameters.at(i); // = something from config file
      // std::vector< std::vector< float > > chargeDistributionParameters_ = chargeDistributionParameters_[i][chargeDistributionParameters_puBin];
      // Pass functions to generateAPVBasline, get back apv baselines in various bins of z for this layer
      // std::cout << "Going into generateAPVBaseline for TIB" << std::endl;
      generateAPVBaseline( occupanciesVsZ, chargeDistributionParameters_[i][chargeDistributionParameters_puBin], apvBaselineDistributions_tib_[i] );
      // std::cout << "DONE : Going into generateAPVBaseline" << std::endl;
    }

    for ( unsigned int i = 0; i < nStrips_tob.size(); ++i ) {
      occupancy_tob[i] = float(nStripsNonZero_tob[i]) / float(nStrips_tob[i]);
      std::vector< float > occupanciesVsZ = occupancy_[4+i][chargeDistributionParameters_puBin];

      // std::cout << "Going into generateAPVBaseline for TOB" << std::endl;
      generateAPVBaseline( occupanciesVsZ, chargeDistributionParameters_[4+i][chargeDistributionParameters_puBin], apvBaselineDistributions_tob_[i] );
      // generateAPVBaseline( occupancy_tob[i], h_charge_tob, apvBaselineDistributions_tob_[i] );
      // std::cout << "DONE : Going into generateAPVBaseline" << std::endl;

    }

    for ( unsigned int i = 0; i < nStrips_tid.size(); ++i ) {
      occupancy_tid[i] = float(nStripsNonZero_tid[i]) / float(nStrips_tid[i]);
      // generateAPVBaseline( occupancy_tid[i], h_charge_tid, apvBaselineDistributions_tid_[i] );
    }


    for ( unsigned int i = 0; i < nStrips_tec.size(); ++i ) {
      occupancy_tec[i] = float(nStripsNonZero_tec[i]) / float(nStrips_tec[i]);
      // generateAPVBaseline( occupancy_tec[i], h_charge_tec, apvBaselineDistributions_tec_[i] );
    }
}

//============================================================================                

void SiStripDigitizerAlgorithm::generateAPVBaseline(
              std::vector< float > occupancyVsZ,
              std::vector< std::vector<float> > chargeDistributionParameters,
              std::vector< TH1F >& baselineDistributions
              ) {

    // std::cout << "N z bins : " << chargeDistributionParameters.size() << std::endl;
    for ( unsigned int i_zBin = 0; i_zBin < chargeDistributionParameters.size(); ++ i_zBin ) {
      TH1F& baselineDistribution = baselineDistributions[ i_zBin ];
      baselineDistribution.Reset();
      std::vector<float> chargeDistributionParameters_i_zBin = chargeDistributionParameters[ i_zBin ];
      float occupancy = occupancyVsZ[ i_zBin ];
      // If occupancy is zero, just fill the APV baseline with zero and return
      // std::cout << "Generating baselines for zbin : " << i_zBin << " " << occupancy << std::endl;
      // std::cout << "Occupancy : " << occupancy << std::endl;
      if ( occupancy == 0. ) {
        baselineDistribution.Fill(0);
        return;
      }

      // Define PDF for the probability for a charge to be deposited in a previous BX for a given occupancy
      unsigned int maxBXWithoutInteraction = log(0.01)/log(1-occupancy);  // Consider BX where probablitiy of interaction is > 1% of occupancy
      TF1 *f_probBX = new TF1("f_probBX","[0]*(1-[0])^x",0,maxBXWithoutInteraction);
      f_probBX->SetParameter(0,occupancy);

      // PDF for amound of charge deposited on a strip
      TF1 *f_probCharge = new TF1("f_probCharge","( ( x >= 20000 ) ? [5]*TMath::Landau(x,[6],[7]) : [0]*TMath::Landau(x,[1],[2]) + exp([3]+[4]*x) )", apv_minAmplitude, 65536 * theElectronPerADC);
      for ( unsigned int i_chargeDistributionParam = 0; i_chargeDistributionParam < chargeDistributionParameters_i_zBin.size(); ++ i_chargeDistributionParam ){
        f_probCharge->SetParameter( i_chargeDistributionParam, chargeDistributionParameters_i_zBin[ i_chargeDistributionParam ] );
      }
      // f_probCharge->SetParameter(0,2.3E-3);
      // f_probCharge->SetParameter(1,1.4E4);
      // f_probCharge->SetParameter(2,3.8E3);

      // myFunc = r.TF1('myFunc','[0]*TMath::Landau(x,[1],[2])',1000,h_scd.GetXaxis().GetXmax())
      // myFunc.SetParameters(2.3E-3, 1.4E4, 3.8E3 )

      double maxChargePicked = 0;


      // Build up distribution of APV baselines for this given occupancy and charge distribution i.e. repeat process several times and store result
      for ( unsigned int n = 0; n < apv_nBaselineToGenerate; ++n ) {

        float baselineQ = 0;
        float timeSinceInteractionInMicroS = 0;
        // unsigned int totalBX = 0;
        unsigned int totalInteractions = 0;
        unsigned int nInteractionsWithSmalChange = 0;

        // Simulate several previous charge deposits in a particular strip
        // Get BX of the charge deposit (how many BX in the past), and how much charge was deposited
        // Calculate how much of that charge is still on the strip in the current BX (BX == 0 ), by decaying the charge by an exponential
        for ( unsigned int i_interaction = 0; i_interaction < apv_nPreviousInteractionsToSimulate; ++i_interaction ) {
          ++totalInteractions;
          unsigned int BX = f_probBX->GetRandom();
          // float charge = chargeDistribution.GetRandom();
          float charge = f_probCharge->GetRandom();
          // if ( charge > 60000 ) {
          //   std::cout << "Sampled charge : " << charge << std::endl;         
          // }
          if ( charge > maxChargePicked ) maxChargePicked = charge;

          // totalBX += BX;
          timeSinceInteractionInMicroS += float(BX) * 25 / 1000;

          float extraChargeToBaseline = ( charge * exp( -1.0 * timeSinceInteractionInMicroS / apv_decayConstantInMicroS ) );

          // Note if this additional charge has a negligible effect on the APV baseline (because it was very far in the past, or only a small charge was deposited)
          // If this happens a few times, then the APV baseline is stable, and there's no point in simulating more charge deposits
          if ( extraChargeToBaseline / baselineQ < apv_smallChangeThreshold ) ++nInteractionsWithSmalChange;         
          if ( nInteractionsWithSmalChange > apv_smallChangeN ) break;

          baselineQ += extraChargeToBaseline;
        }

        // Convert to V, and store (perhaps the APV baseline should be stored as a charge?)
        float baselineV = baselineQ * apv_mVPerQ * apv_fCPerElectron;
        if ( baselineV > apv_maxResponse ) baselineV = apv_maxResponse;
        baselineDistribution.Fill( baselineV );
      }
      // std::cout << "Maximum charge generated : " << maxChargePicked << std::endl;
      // std::cout << baselineDistribution.GetEntries() << " " << baselineDistribution.GetMean() << std::endl;
  }
}

//============================================================================                


void
SiStripDigitizerAlgorithm::digitize(
			   edm::DetSet<SiStripDigi>& outdigi,
			   edm::DetSet<SiStripRawDigi>& outrawdigi,
         edm::DetSet<SiStripRawDigi>& outStripAmplitudes,
         edm::DetSet<SiStripRawDigi>& outStripAmplitudesPostAPV,
         edm::DetSet<SiStripRawDigi>& outStripAPVBaselines,
			   edm::DetSet<StripDigiSimLink>& outLink,
			   const StripGeomDetUnit *det,
			   edm::ESHandle<SiStripGain> & gainHandle,
			   edm::ESHandle<SiStripThreshold> & thresholdHandle,
			   edm::ESHandle<SiStripNoises> & noiseHandle,
			   edm::ESHandle<SiStripPedestals> & pedestalHandle,
			   std::vector<std::pair<int,std::bitset<6>>> & theAffectedAPVvector,
                           CLHEP::HepRandomEngine* engine,
         const TrackerTopology *tTopo
          ) {
  unsigned int detID = det->geographicalId().rawId();
  int numStrips = (det->specificTopology()).nstrips();  

  // Moved from later (if CommonModeNoise)
  DetId  detId(detID);
  uint32_t SubDet = detId.subdetId();

  // Need z coordinate of detset
  const StripTopology * topol = dynamic_cast<const StripTopology*>(&(det->specificTopology()));
  LocalPoint localPos = topol->localPosition(0);
  GlobalPoint globalPos = det->surface().toGlobal(Local3DPoint(localPos.x(),localPos.y(),localPos.z()));
  float detSet_z = fabs( globalPos.z() );
  // Index in apv baseline distributions
  std::vector< float >::iterator low = std::lower_bound( chargeDistributionParameters_zBinEdges_.begin(), chargeDistributionParameters_zBinEdges_.end(), detSet_z );
  unsigned int detSet_zBin = low - chargeDistributionParameters_zBinEdges_.begin() - 1;
  // std::cout << "detSet_z, bin : " << detSet_z << " " << detSet_zBin << std::endl;
  // std::cout << "zBin : " << detSet_zBin << std::endl;
  // Get the corresponding APV baseline distribution for this subdetector and layer
  TH1F* apvBaselineDistribution = 0;
  int layer = -1;
  if(SubDet==3) {
    layer = tTopo->tibLayer(detId);
    // std::cout << "Layer : " << layer << std::endl;
    apvBaselineDistribution = &apvBaselineDistributions_tib_[layer-1][detSet_zBin];
  }
  else if(SubDet==4){
    layer = tTopo->tidRing(detId);
    apvBaselineDistribution = &apvBaselineDistributions_tid_[layer-1][detSet_zBin];
  } 
  else if(SubDet==5){
    layer = tTopo->tobLayer(detId);
    // std::cout << "Layer : " << layer << std::endl;
    apvBaselineDistribution = &apvBaselineDistributions_tob_[layer-1][detSet_zBin];
  } 
  else if(SubDet==6){
    layer = tTopo->tecRing(detId);
    apvBaselineDistribution = &apvBaselineDistributions_tec_[layer-1][detSet_zBin];
  } 


  const SiPileUpSignals::SignalMapType* theSignal(theSiPileUpSignals->getSignal(detID));  

  std::vector<float> detAmpl(numStrips, 0.);
  if(theSignal) {
    for(const auto& amp : *theSignal) {
      detAmpl[amp.first] = amp.second;
    }
  }

  //removing signal from the dead (and HIP effected) strips
  std::vector<bool>& badChannels = allBadChannels[detID];
  for(int strip =0; strip < numStrips; ++strip) {
    if(badChannels[strip]) {detAmpl[strip] = 0.;}
  }

  // Store SCD, before APV sim
  for(int strip =0; strip < numStrips; ++strip) {
    outStripAmplitudes.push_back(SiStripRawDigi(detAmpl[strip]/theElectronPerADC));;
  }

  // Simulate APV response for each strip
  // std::cout << "Simulating APV response for this detset : " << SubDet << std::endl;
  // std::cout << "APV baseline info : " << apvBaselineDistribution->GetEntries() << " " << apvBaselineDistribution->GetMean() << std::endl;
  if ( SubDet == 3 || SubDet == 5 ) {
    for(int strip =0; strip < numStrips; ++strip) {
      if (detAmpl[strip] > 0 ) {
        // Convert charge from electrons to fC
        double stripCharge = detAmpl[strip]*apv_fCPerElectron;

        // Get APV baseline
        double baselineV = apvBaselineDistribution->GetRandom();
        // Store APV baseline for this strip
        outStripAPVBaselines.push_back(SiStripRawDigi(baselineV));

        // Fitted parameters from G Hall/M Raymond
        double maxResponse = apv_maxResponse;
        double rate = apv_rate;
        double baselineQ = apv_maxResponse;

        // Convert V0 into baseline charge
        if ( baselineV < baselineQ ) {
          baselineQ = - 1.0 * rate * log( 2 * maxResponse / ( baselineV + maxResponse ) - 1);
        }

        // Add charge deposited in this BX
        double newStripCharge = baselineQ + stripCharge;

        // Apply APV response
        double signalV = 2 * maxResponse / ( 1 + exp( -1.0 * newStripCharge / rate) ) - maxResponse;
        double gain = signalV - baselineV;

        // Convert gain (mV) to charge (assuming linear region of APV) and then to electrons
        double outputCharge = gain/apv_mVPerQ;
        double outputChargeInADC = outputCharge / apv_fCPerElectron;

        // Output charge back to original container
        detAmpl[strip] = outputChargeInADC;
      }
    }    
  }
  // std::cout << "DONE : Simulating APV response for this detset" << std::endl;


  // Store SCD, after APV sim
  for(int strip =0; strip < numStrips; ++strip) outStripAmplitudesPostAPV.push_back(SiStripRawDigi(detAmpl[strip]/theElectronPerADC));;



  if(APVSaturationFromHIP){
    //Implementation of the proper charge scaling function. Need consider resaturation effect:
    //The probability map gives  the probability that at least one HIP happened during the last N bunch crossings (cfr APV recovery time).
    //The impact on the charge depends on the clostest HIP occurance (in terms of bunch crossing).
    //The function discribing the APV recovery is therefore the weighted average function which takes into account all possibilities of HIP occurances across the last bx's.

    // do this step here because we now have access to luminosity information
    if(FirstDigitize_) {

      for(std::map<int,float>::iterator iter = mapOfAPVprobabilities.begin(); iter != mapOfAPVprobabilities.end(); ++iter){
	std::bitset<6> bs;
	for(int Napv=0;Napv<6;Napv++){
	  float cursor=CLHEP::RandFlat::shoot(engine);
	  bs[Napv]=cursor < iter->second*APVSaturationProb_ ? true:false;  //APVSaturationProb has been scaled by PU luminosity
	}
	SiStripTrackerAffectedAPVMap[iter->first]=bs;
      }

      NumberOfBxBetweenHIPandEvent=1e3;
      bool HasAtleastOneAffectedAPV=false;
      while(!HasAtleastOneAffectedAPV){
        for(int bx=floor(300.0/25.0);bx>0;bx--){ //Reminder: make these numbers not hard coded!!
          float temp=CLHEP::RandFlat::shoot(engine)<0.5?1:0;
          if(temp==1 && bx<NumberOfBxBetweenHIPandEvent){
            NumberOfBxBetweenHIPandEvent=bx;
            HasAtleastOneAffectedAPV=true;
          }
        }
      }

      FirstDigitize_ = false;
    }

    std::bitset<6> & bs=SiStripTrackerAffectedAPVMap[detID];

    if(bs.any()){
      // store this information so it can be saved to the event later
      theAffectedAPVvector.push_back(std::make_pair(detID,bs));

      if(!PreMixing_) {

    // Here below is the scaling function which describes the evolution of the baseline (i.e. how the charge is suppressed).
    // This must be replaced as soon as we have a proper modeling of the baseline evolution from VR runs
    float Shift=1-NumberOfBxBetweenHIPandEvent/floor(300.0/25.0); //Reminder: make these numbers not hardcoded!! 
    float randomX=CLHEP::RandFlat::shoot(engine);
    float scalingValue=(randomX-Shift)*10.0/7.0-3.0/7.0;

    for(int strip =0; strip < numStrips; ++strip) {
      if(!badChannels[strip] &&  bs[strip/128]==1){
        detAmpl[strip] *=scalingValue>0?scalingValue:0.0;
      }
    }
        }
      }
  }


  SiStripNoises::Range detNoiseRange = noiseHandle->getRange(detID);
  SiStripApvGain::Range detGainRange = gainHandle->getRange(detID);
  SiStripPedestals::Range detPedestalRange = pedestalHandle->getRange(detID);

// -----------------------------------------------------------

  auto& firstChannelWithSignal = firstChannelsWithSignal[detID];
  auto& lastChannelWithSignal = lastChannelsWithSignal[detID];
  auto iAssociationInfoByChannel=associationInfoForDetId_.find(detID); // Use an iterator so that I can easily remove it once finished

  if(zeroSuppression){

    //Adding the strip noise
    //------------------------------------------------------  
    if(noise){ 
                         
      if(SingleStripNoise){
//      std::cout<<"In SSN, detId="<<detID<<std::endl;
        std::vector<float> noiseRMSv; 
        noiseRMSv.clear(); 
        noiseRMSv.insert(noiseRMSv.begin(),numStrips,0.); 
        for(int strip=0; strip< numStrips; ++strip){ 
          if(!badChannels[strip]){
            float gainValue = gainHandle->getStripGain(strip, detGainRange); 
            noiseRMSv[strip] = (noiseHandle->getNoise(strip,detNoiseRange))* theElectronPerADC/gainValue;
            //std::cout<<"<SiStripDigitizerAlgorithm::digitize>: gainValue: "<<gainValue<<"\tnoiseRMSv["<<strip<<"]: "<<noiseRMSv[strip]<<std::endl;
          }
        }
         theSiNoiseAdder->addNoiseVR(detAmpl, noiseRMSv, engine);
      } else {
          int RefStrip = int(numStrips/2.);
          while(RefStrip<numStrips&&badChannels[RefStrip]){ //if the refstrip is bad, I move up to when I don't find it 
            RefStrip++;
          } 
          if(RefStrip<numStrips){
            float RefgainValue = gainHandle->getStripGain(RefStrip, detGainRange);
            float RefnoiseRMS = noiseHandle->getNoise(RefStrip,detNoiseRange) *theElectronPerADC/RefgainValue; 
          
            theSiNoiseAdder->addNoise(detAmpl,firstChannelWithSignal,lastChannelWithSignal,numStrips,RefnoiseRMS, engine);
            //std::cout<<"<SiStripDigitizerAlgorithm::digitize>: RefgainValue: "<<RefgainValue<<"\tRefnoiseRMS: "<<RefnoiseRMS<<std::endl;
          }
      }
    }//if noise

    DigitalVecType digis;
    theSiZeroSuppress->suppress(theSiDigitalConverter->convert(detAmpl, gainHandle, detID), digis, detID,noiseHandle,thresholdHandle);
    // Now do the association to truth. Note that if truth association was turned off in the configuration this map
    // will be empty and the iterator will always equal associationInfoForDetId_.end().
    if( iAssociationInfoByChannel!=associationInfoForDetId_.end() ) { // make sure the readings for this DetID aren't completely from noise
      for( const auto& iDigi : digis ) {
        auto& associationInfoByChannel=iAssociationInfoByChannel->second;
        const std::vector<AssociationInfo>& associationInfo=associationInfoByChannel[iDigi.channel()];

        // Need to find the total from all sim hits, because this might not be the same as the total
        // digitised due to noise or whatever.
        float totalSimADC=0;
        for( const auto& iAssociationInfo : associationInfo ) totalSimADC+=iAssociationInfo.contributionToADC;
        // Now I know that I can loop again and create the links
        for( const auto& iAssociationInfo : associationInfo ) {
          // Note simHitGlobalIndex used to have +1 because TrackerHitAssociator (the only place I can find this value being used)
          // expected counting to start at 1, not 0.  Now changed.
          outLink.push_back( StripDigiSimLink( iDigi.channel(), iAssociationInfo.trackID, iAssociationInfo.simHitGlobalIndex, iAssociationInfo.tofBin, iAssociationInfo.eventID, iAssociationInfo.contributionToADC/totalSimADC ) );
        } // end of loop over associationInfo
      } // end of loop over the digis
    } // end of check that iAssociationInfoByChannel is a valid iterator
    outdigi.data = digis;
  }//if zeroSuppression

  if(!zeroSuppression){
    //if(noise){
      // the constant pedestal offset is needed because
      //   negative adc counts are not allowed in case
      //   Pedestal and CMN subtraction is performed.
      //   The pedestal value read from the conditions
      //   is pedValue and after the pedestal subtraction
      //   the baseline is zero. The Common Mode Noise
      //   is not subtracted from the negative adc counts
      //   channels. Adding pedOffset the baseline is set
      //   to pedOffset after pedestal subtraction and CMN
      //   is subtracted to all the channels since none of
      //   them has negative adc value. The pedOffset is
      //   treated as a constant component in the CMN
      //   estimation and subtracted as CMN.
      
         
		//calculating the charge deposited on each APV and subtracting the shift
		//------------------------------------------------------
		if(BaselineShift){
		   theSiNoiseAdder->addBaselineShift(detAmpl, badChannels);
		}
		
		//Adding the strip noise
		//------------------------------------------------------						 
		if(noise){
		    std::vector<float> noiseRMSv;
			noiseRMSv.clear();
		    noiseRMSv.insert(noiseRMSv.begin(),numStrips,0.);
			
		    if(SingleStripNoise){
			    for(int strip=0; strip< numStrips; ++strip){
			  		if(!badChannels[strip]) noiseRMSv[strip] = (noiseHandle->getNoise(strip,detNoiseRange))* theElectronPerADC;
			  	}
			
	    	} else {
			    int RefStrip = 0; //int(numStrips/2.);
		    	    while(RefStrip<numStrips&&badChannels[RefStrip]){ //if the refstrip is bad, I move up to when I don't find it
					RefStrip++;
				}
				if(RefStrip<numStrips){
					float noiseRMS = noiseHandle->getNoise(RefStrip,detNoiseRange) *theElectronPerADC;
					for(int strip=0; strip< numStrips; ++strip){
			       		if(!badChannels[strip]) noiseRMSv[strip] = noiseRMS;
			  		}
				}
			}
			
                    theSiNoiseAdder->addNoiseVR(detAmpl, noiseRMSv, engine);
		}			
		
		//adding the CMN
		//------------------------------------------------------
        if(CommonModeNoise){
		  float cmnRMS = 0.;
		  if(SubDet==3){
		    cmnRMS = cmnRMStib;
		  }else if(SubDet==4){
		    cmnRMS = cmnRMStid;
		  }else if(SubDet==5){
		    cmnRMS = cmnRMStob;
		  }else if(SubDet==6){
		    cmnRMS = cmnRMStec;
		  }
		  cmnRMS *= theElectronPerADC;
                  theSiNoiseAdder->addCMNoise(detAmpl, cmnRMS, badChannels, engine);
		}
		
        		
		//Adding the pedestals
		//------------------------------------------------------
		
		std::vector<float> vPeds;
		vPeds.clear();
		vPeds.insert(vPeds.begin(),numStrips,0.);
		
		if(RealPedestals){
		    for(int strip=0; strip< numStrips; ++strip){
			   if(!badChannels[strip]) vPeds[strip] = (pedestalHandle->getPed(strip,detPedestalRange)+pedOffset)* theElectronPerADC;
		    }
        } else {
		    for(int strip=0; strip< numStrips; ++strip){
			  if(!badChannels[strip]) vPeds[strip] = pedOffset* theElectronPerADC;
			}
		}
		
		theSiNoiseAdder->addPedestals(detAmpl, vPeds);	
		
		 
	//if(!RealPedestals&&!CommonModeNoise&&!noise&&!BaselineShift&&!APVSaturationFromHIP){
    //  edm::LogWarning("SiStripDigitizer")<<"You are running the digitizer without Noise generation and without applying Zero Suppression. ARE YOU SURE???";
    //}else{							 
    
    DigitalRawVecType rawdigis = theSiDigitalConverter->convertRaw(detAmpl, gainHandle, detID);

    // Now do the association to truth. Note that if truth association was turned off in the configuration this map
    // will be empty and the iterator will always equal associationInfoForDetId_.end().
    if( iAssociationInfoByChannel!=associationInfoForDetId_.end() ) { // make sure the readings for this DetID aren't completely from noise
      // N.B. For the raw digis the channel is inferred from the position in the vector.
      // I'VE NOT TESTED THIS YET!!!!!
      // ToDo Test this properly.
      for( size_t channel=0; channel<rawdigis.size(); ++channel ) {
        auto& associationInfoByChannel=iAssociationInfoByChannel->second;
        const auto iAssociationInfo=associationInfoByChannel.find(channel);
        if( iAssociationInfo==associationInfoByChannel.end() ) continue; // Skip if there is no sim information for this channel (i.e. it's all noise)
        const std::vector<AssociationInfo>& associationInfo=iAssociationInfo->second;

        // Need to find the total from all sim hits, because this might not be the same as the total
        // digitised due to noise or whatever.
        float totalSimADC=0;
        for( const auto& iAssociationInfo : associationInfo ) totalSimADC+=iAssociationInfo.contributionToADC;
        // Now I know that I can loop again and create the links
        for( const auto& iAssociationInfo : associationInfo ) {
          // Note simHitGlobalIndex used to have +1 because TrackerHitAssociator (the only place I can find this value being used)
          // expected counting to start at 1, not 0.  Now changed.
          outLink.push_back( StripDigiSimLink( channel, iAssociationInfo.trackID, iAssociationInfo.simHitGlobalIndex, iAssociationInfo.tofBin, iAssociationInfo.eventID, iAssociationInfo.contributionToADC/totalSimADC ) );
        } // end of loop over associationInfo
      } // end of loop over the digis
    } // end of check that iAssociationInfoByChannel is a valid iterator

    outrawdigi.data = rawdigis;
	
	//}
  }

  // Now that I've finished with this entry in the map of associations, I can remove it.
  // Note that there might not be an association if the ADC reading is from noise in which
  // case associationIsValid will be false.
  if( iAssociationInfoByChannel!=associationInfoForDetId_.end() ) associationInfoForDetId_.erase(iAssociationInfoByChannel);
}
