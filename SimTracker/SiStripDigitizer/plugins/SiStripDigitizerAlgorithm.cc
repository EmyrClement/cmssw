// File: SiStripDigitizerAlgorithm.cc
// Description:  Steering class for digitization.
// Modified 15/May/2013 mark.grimes@bristol.ac.uk - Modified so that the digi-sim link has the correct
// index for the sim hits stored. It was previously always set to zero (I won't mention that it was
// me who originally wrote that).
// Modified on Feb 11, 2015: prolay.kumar.mal@cern.ch & Jean-Laurent.Agram@cern.ch
//                           Added/Modified the individual strip noise in zero suppression
//                           mode from the conditions DB; previously, the digitizer used to
//                           consider the noise value for individual strips inside a module from
//                           the central strip noise value.
//////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <vector>
#include <algorithm>
#include <iostream>
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "SiStripDigitizerAlgorithm.h"
#include "SimDataFormats/TrackingHit/interface/PSimHitContainer.h"
#include "SimDataFormats/TrackerDigiSimLink/interface/StripDigiSimLink.h"
#include "DataFormats/Common/interface/DetSetVector.h"
#include "DataFormats/GeometrySurface/interface/BoundSurface.h"
#include "SimGeneral/HepPDTRecord/interface/ParticleDataTable.h"
#include "CalibTracker/Records/interface/SiStripDependentRecords.h"
#include "CondFormats/SiStripObjects/interface/SiStripLorentzAngle.h"
#include "CondFormats/DataRecord/interface/SiStripCondDataRecords.h"
#include "CondFormats/SiStripObjects/interface/SiStripNoises.h"
#include "CondFormats/SiStripObjects/interface/SiStripThreshold.h"
#include "CondFormats/SiStripObjects/interface/SiStripPedestals.h"
#include "CondFormats/SiStripObjects/interface/SiStripBadStrip.h"
#include "CLHEP/Random/RandFlat.h"

#include <cstring>
#include <sstream>

#include <boost/algorithm/string.hpp>

SiStripDigitizerAlgorithm::SiStripDigitizerAlgorithm(const edm::ParameterSet& conf):
  lorentzAngleName(conf.getParameter<std::string>("LorentzAngle")),
  theThreshold(conf.getParameter<double>("NoiseSigmaThreshold")),
  cmnRMStib(conf.getParameter<double>("cmnRMStib")),
  cmnRMStob(conf.getParameter<double>("cmnRMStob")),
  cmnRMStid(conf.getParameter<double>("cmnRMStid")),
  cmnRMStec(conf.getParameter<double>("cmnRMStec")),
  APVSaturationProbScaling_(conf.getParameter<double>("APVSaturationProbScaling")),
  makeDigiSimLinks_(conf.getUntrackedParameter<bool>("makeDigiSimLinks", false)),
  peakMode(conf.getParameter<bool>("APVpeakmode")),
  noise(conf.getParameter<bool>("Noise")),
  RealPedestals(conf.getParameter<bool>("RealPedestals")), 
  SingleStripNoise(conf.getParameter<bool>("SingleStripNoise")),
  CommonModeNoise(conf.getParameter<bool>("CommonModeNoise")),
  BaselineShift(conf.getParameter<bool>("BaselineShift")),
  APVSaturationFromHIP(conf.getParameter<bool>("APVSaturationFromHIP")),
  theFedAlgo(conf.getParameter<int>("FedAlgorithm")),
  zeroSuppression(conf.getParameter<bool>("ZeroSuppression")),
  theElectronPerADC(conf.getParameter<double>( peakMode ? "electronPerAdcPeak" : "electronPerAdcDec" )),

  apv_minAmplitude(conf.getParameter<double>( "apv_minAmplitude" )), // 10000;
  apv_decayConstantInMicroS(conf.getParameter<double>( "apv_decayConstantInMicroS" )), // 200;
  apv_nPreviousInteractionsToSimulate(conf.getParameter<unsigned int>( "apv_nPreviousInteractionsToSimulate" )), //  = 100;
  apv_nBaselineToGenerate(conf.getParameter<unsigned int>( "apv_nBaselineToGenerate" )), // = 2000;
  apv_smallChangeThreshold(conf.getParameter<double>( "apv_smallChangeThreshold" )), // 0.001 
  apv_smallChangeN(conf.getParameter<unsigned int>( "apv_smallChangeN" )), //5

  apv_maxResponse(conf.getParameter<double>( "apv_maxResponse" )), // 729

  apv_rate(conf.getParameter<double>( "apv_rate" )), // 66.2
  apv_mVPerQ(conf.getParameter<double>( "apv_mVPerQ" )), // 5.5
  apv_fCPerElectron(conf.getParameter<double>( "apvfCPerElectron" )), // 1.602e-4

  theTOFCutForPeak(conf.getParameter<double>("TOFCutForPeak")),
  theTOFCutForDeconvolution(conf.getParameter<double>("TOFCutForDeconvolution")),
  tofCut(peakMode ? theTOFCutForPeak : theTOFCutForDeconvolution),
  cosmicShift(conf.getUntrackedParameter<double>("CosmicDelayShift")),
  inefficiency(conf.getParameter<double>("Inefficiency")),
  pedOffset((unsigned int)conf.getParameter<double>("PedestalsOffset")),
  PreMixing_(conf.getParameter<bool>("PreMixingMode")),
  theSiHitDigitizer(new SiHitDigitizer(conf)),
  theSiPileUpSignals(new SiPileUpSignals()),
  theSiNoiseAdder(new SiGaussianTailNoiseAdder(theThreshold)),
  theSiDigitalConverter(new SiTrivialDigitalConverter(theElectronPerADC, PreMixing_)),
  theSiZeroSuppress(new SiStripFedZeroSuppression(theFedAlgo)),
  APVProbabilityFile(conf.getParameter<edm::FileInPath>("APVProbabilityFile")),
  apvBaselineDistributions_tib_(4, std::vector<TH1F>() ),
  apvBaselineDistributions_tob_(6, std::vector<TH1F>() ),
  apvBaselineDistributions_tid_(3, std::vector<TH1F>() ),
  apvBaselineDistributions_tec_(7, std::vector<TH1F>() )
   {

  if (peakMode) {
    LogDebug("StripDigiInfo")<<"APVs running in peak mode (poor time resolution)";
  } else {
    LogDebug("StripDigiInfo")<<"APVs running in deconvolution mode (good time resolution)";
  };
  if(SingleStripNoise) LogDebug("SiStripDigitizerAlgorithm")<<" SingleStripNoise: ON";
  else LogDebug("SiStripDigitizerAlgorithm")<<" SingleStripNoise: OFF";
  if(CommonModeNoise) LogDebug("SiStripDigitizerAlgorithm")<<" CommonModeNoise: ON";
  else LogDebug("SiStripDigitizerAlgorithm")<<" CommonModeNoise: OFF";
  if(PreMixing_ && APVSaturationFromHIP) throw cms::Exception("PreMixing does not work with HIP loss simulation yet");
  if(APVSaturationFromHIP){  
    std::string line; 
    APVProbaFile.open((APVProbabilityFile.fullPath()).c_str());
    if (APVProbaFile.is_open()){
      while ( getline (APVProbaFile,line) ){
        std::vector<std::string> strs;
          boost::split(strs,line,boost::is_any_of(" "));
          if(strs.size()==2){
            mapOfAPVprobabilities[std::stoi(strs.at(0))]=std::stof(strs.at(1));
          }
      }
      APVProbaFile.close();
    }else throw cms::Exception("MissingInput")
         << "It seems that the APV probability list is missing\n";
  }

chargeDistributionParameters_ = {
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.211002376829, 8000.01920483, 2626.23749697, -0.261640309695, -0.000746183644997, 0.13664680622, 12797.2372063, 2315.51410247, },      std::vector<float> {0.171160545265, 8000.27026488, 2944.75772704, -0.386216186402, -0.000675276219916, 0.0626872478327, 16613.4774003, 3631.99354302, },        std::vector<float> {0.159772790649, 8000.21291091, 3556.05991371, -0.567359627831, -0.000639186686755, 0.0739990678161, 15388.7345472, 3952.19848537, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.213276497606, 8000.12186581, 2532.42537469, -0.194012774528, -0.000778450313297, 0.236732042093, 10000.0000026, 2099.26302804, },       std::vector<float> {0.166261187789, 8000.41690876, 3082.48870197, -0.502528731231, -0.000635774693251, 0.0562443814954, 17217.9489297, 4094.8287684, },       std::vector<float> {0.161986557145, 8000.36345446, 3177.40724451, -0.55719721543, -0.000615640819982, 0.0546184911559, 18211.9983944, 4043.01730747, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.211396588748, 8000.02807098, 2712.61552853, -0.26672845548, -0.000766153340824, 0.2492141073, 10000.0001195, 2080.32073245, },      std::vector<float> {0.178202975547, 8000.46761716, 3184.71894787, -0.473365125584, -0.000676045044818, 0.0701076952052, 15276.5835845, 3914.31092022, },      std::vector<float> {0.157486036366, 8000.44132687, 3351.40639304, -0.681041528656, -0.000580200863138, 0.0638694297239, 15675.4817924, 4506.35626974, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.219099005608, 8000.04281596, 2604.68404903, -0.319799988814, -0.000747526628113, 0.211287452567, 10000.0, 2283.81174002, },       std::vector<float> {0.182361606119, 8001.2345134, 3019.53315664, -0.494099155664, -0.000663704757299, 0.0718130399293, 15343.5119158, 3809.95413523, },       std::vector<float> {0.156450556587, 8000.43538244, 3651.19449978, -0.627668032495, -0.000610466793869, 0.0648537153899, 16373.1774448, 4219.95334739, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.222098542589, 8000.27868662, 2733.1018564, -0.325396734578, -0.00077816734542, 0.229437938967, 10283.6548291, 2286.67842708, },       std::vector<float> {0.186125328039, 8000.00217599, 3220.21990035, -0.525292849711, -0.000688133944746, 0.0861055719735, 14240.7519171, 3847.58505727, },      std::vector<float> {0.168171729313, 8000.02377975, 3571.73437608, -0.678435579734, -0.000627101535972, 0.103690786798, 12042.8324129, 4045.06906971, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.202402303814, 8000.01141981, 2739.67729657, -0.331010289567, -0.000727653143026, 0.102189928656, 12597.3964457, 3007.94846473, },       std::vector<float> {0.183218649331, 8002.36345108, 3197.31774552, -0.449810814631, -0.000699701429233, 0.0510405125708, 18254.9433281, 4363.19718775, },      std::vector<float> {0.165197920403, 8000.30685569, 3237.66820226, -0.700763189581, -0.000581237862055, 0.0480482327877, 19193.0315811, 4618.01539958, },    },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.229585491559, 8000.02673253, 2201.99847224, -0.33597630126, -0.000693966035999, 0.263674278573, 11508.7861473, 1636.66625751, },      std::vector<float> {0.238951427183, 8000.00098344, 2082.63961167, -0.555279182481, -0.00061926711401, 0.101457327612, 12945.8590156, 2761.28447758, },      std::vector<float> {0.208035257831, 8000.17045008, 2498.97562036, -0.483179891297, -0.000656375611243, 0.0447493925152, 20278.7835441, 3698.43478354, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.23386093101, 8000.00041137, 2071.1866977, -0.495339479426, -0.00062782806719, 0.100117995582, 12197.1293887, 2893.40960677, },      std::vector<float> {0.203552743552, 8000.08648246, 2345.06963682, -0.375452796118, -0.000677447431584, 0.147828081781, 10000.0004611, 2852.68711971, },       std::vector<float> {0.195684166189, 8000.04791487, 2419.23298182, -0.38580442034, -0.000662514507557, 0.0538449950555, 15986.5009064, 3961.7621879, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.234419285202, 8000.20860699, 2117.14323419, -0.590431264783, -0.00060700666049, 0.123227339676, 10000.0, 2856.83354324, },      std::vector<float> {0.226791626215, 8000.54217939, 2236.5607901, -0.463079463317, -0.00066316327204, 0.133717177157, 10000.0000153, 3023.3144985, },      std::vector<float> {0.201982126735, 8005.72083787, 2552.35912013, -0.498878988275, -0.000650884675436, 0.230421583883, 11304.7013827, 1766.92052552, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.225692080419, 8174.81811506, 2173.26870654, -0.729296509621, -0.000556794838842, 0.149987786978, 10000.0000139, 2540.92463841, },       std::vector<float> {0.232351539535, 8000.41763954, 2233.24174422, -0.49349538954, -0.000659049542698, 0.141018486401, 11450.8075469, 2647.4604833, },       std::vector<float> {0.20046498558, 8000.79655762, 2629.51239958, -0.407742848088, -0.000691862281563, 0.0991229413088, 11817.0537834, 3512.59685158, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.219948580147, 8329.58234316, 2313.09807688, -0.728839431701, -0.000567612619447, 0.192146536225, 10000.0000829, 2338.27456416, },       std::vector<float> {0.223952209217, 8002.10466257, 2374.67714363, -0.470000660319, -0.000675307678014, 0.0789824379294, 14552.8495835, 3390.92592608, },      std::vector<float> {0.199365412326, 8034.40093438, 2768.04346748, -0.553955588623, -0.00065426810193, 0.0676872480142, 15597.3110901, 3971.27627727, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.243484168767, 8000.00003572, 2012.5184796, -0.571846521526, -0.000602929430645, 0.150921787228, 10000.0000035, 2387.55721833, },      std::vector<float> {0.213572462009, 8000.51862275, 2154.26657946, -0.565823379596, -0.000596318102554, 0.090972232963, 10000.0000042, 3690.81523755, },       std::vector<float> {0.185522533169, 8000.2973739, 2778.3959524, -0.368245530162, -0.00069186656448, 0.0449099389232, 19343.5887433, 4041.50047985, },     },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.210279567573, 8013.65979726, 3135.10945605, -0.301245083655, -0.000804927559918, 0.230215818663, 11072.1810952, 2118.71104838, },       std::vector<float> {0.171964729963, 8000.39382826, 3883.31364935, -0.309711286526, -0.000787530305501, 0.241151301797, 11278.5564838, 2198.14122155, },       std::vector<float> {0.165170616055, 8000.8121149, 3810.03731045, -0.28808083561, -0.000780941831423, 0.16133960834, 10000.0000313, 3130.99513701, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.21577242357, 8026.48239827, 2966.9944412, -0.220396130775, -0.000839026751116, 0.192975467817, 10000.0, 2507.40668901, },       std::vector<float> {0.166861537408, 8000.4579647, 4137.42012253, -0.359025914695, -0.000762388022557, 0.152547271393, 10929.482235, 2975.95752218, },       std::vector<float> {0.143951428217, 8000.68267181, 4071.18204285, -0.59767795016, -0.000607291607321, 0.101635880267, 14699.3414461, 3058.07487242, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.20099617758, 8377.8619224, 3118.96187659, -0.300005625258, -0.000786297455811, 0.199824054276, 10000.0000005, 2538.49540744, },       std::vector<float> {0.17769597326, 8001.45549902, 3608.2058333, -0.306445080307, -0.000780966313685, 0.212022847664, 10000.0000044, 2585.75848045, },       std::vector<float> {0.160164429234, 8000.50465181, 4371.54245592, -0.544680812182, -0.000691880847374, 0.121585433905, 12712.8294942, 3402.07111848, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.211819453783, 8759.64453934, 3030.274949, -0.321347668501, -0.000789592011279, 0.227726735414, 10975.9116903, 2242.29592169, },       std::vector<float> {0.17374381215, 8001.34147597, 4017.41613042, -0.295815024669, -0.000806817794169, 0.194665261071, 11375.7621312, 2616.85185721, },      std::vector<float> {0.156220199544, 8001.21963916, 4794.94030209, -0.530380308199, -0.000705937810822, 0.0987235884808, 14396.911503, 3636.87763297, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.20722207214, 8998.42259814, 3137.24218634, -0.431233927057, -0.000746111688216, 0.218233606691, 10257.6086173, 2438.59564772, },      std::vector<float> {0.17179898725, 8000.29233601, 4278.77413506, -0.36926722354, -0.000787260112154, 0.230021106662, 10843.7513054, 2459.45190965, },       std::vector<float> {0.149335031941, 8000.00036106, 5907.30386738, -0.641833588779, -0.000679743680771, 0.144462904756, 11915.3260754, 3317.10649519, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.1929990682, 8433.7954686, 3118.33832945, -0.220985826546, -0.000810375548953, 0.244034361483, 11026.3017165, 2145.84357848, },      std::vector<float> {0.189541466123, 8000.23788463, 3061.33053629, -0.213490676191, -0.000803356534806, 0.192380406406, 11501.7050865, 2419.01751277, },       std::vector<float> {0.143640842347, 8000.67921258, 4486.97680423, -0.459734693429, -0.000686202410666, 0.0957525721059, 14726.423663, 3412.43774966, },     },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.208958065752, 9318.73188983, 2629.79433704, -0.756992427308, -0.000562286243964, 0.181325556798, 10180.960794, 2447.92114818, },      std::vector<float> {0.214969798394, 8000.03367304, 3367.55240516, -0.000264873619379, -0.000999766754145, 0.190796546862, 11839.6356665, 2280.61790976, },      std::vector<float> {0.173227732999, 8002.02759132, 3497.58509486, -0.293351488945, -0.000758979521346, 0.244708727697, 11383.3703906, 2000.04120375, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.204973458772, 8512.75389446, 2933.41282165, -0.426186199584, -0.000725298375372, 0.124629707418, 10000.0000002, 3349.81157218, },       std::vector<float> {0.186580533868, 8000.94771277, 3312.91876404, -0.41073789511, -0.000731479703711, 0.164177154006, 10000.0001641, 2820.10945105, },      std::vector<float> {0.163189872275, 8000.4743171, 3694.38891014, -0.583358133318, -0.000632264470298, 0.161476295919, 11139.6918373, 2709.26688366, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.217376039853, 8524.05237739, 2759.72378434, -0.427005167718, -0.000730126467848, 0.140062819438, 10000.000004, 3114.93647127, },      std::vector<float> {0.196698072233, 8453.7437622, 3029.07574951, -0.369972650035, -0.000748284220405, 0.231868315445, 10112.6768227, 2383.65212582, },      std::vector<float> {0.167006693366, 10143.5608848, 3074.92381386, -0.653056462615, -0.000585361808249, 0.210551117329, 10000.0004423, 2705.01121899, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.224545304993, 8000.03237767, 3016.81073941, -4.16490484199e-05, -0.000959548836643, 0.19316438395, 10000.0, 2562.68773845, },       std::vector<float> {0.191381469401, 8413.1627156, 3386.46357558, -0.350070985403, -0.000768024785386, 0.231974297731, 10697.1259506, 2285.06191075, },      std::vector<float> {0.173764583669, 8000.52958621, 3855.411213, -0.35155819831, -0.000775112390373, 0.143480450428, 12207.8149616, 2988.57656465, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.209098639991, 9206.42742794, 2821.25807531, -0.683219433361, -0.000622217882588, 0.172700351345, 10000.0000022, 2719.62887338, },       std::vector<float> {0.193074003394, 8965.73397088, 3381.6628968, -0.373734521494, -0.000769660699158, 0.224655431829, 10262.1630608, 2478.42324509, },      std::vector<float> {0.167824568028, 8000.13209147, 4062.74621939, -0.527262956508, -0.000705416252557, 0.123757332704, 13568.691006, 3154.03533167, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.205019883677, 8721.23828177, 2807.74538135, -0.468429463514, -0.000689272184289, 0.174856503416, 10779.1652089, 2465.36569394, },       std::vector<float> {0.185799353424, 8717.11003098, 3424.47106452, -0.425081556762, -0.000749726490355, 0.145333814049, 10000.0, 3387.25958619, },       std::vector<float> {0.161463245817, 8000.26306311, 3760.16466339, -0.442548478261, -0.000697231208114, 0.0790143526239, 17385.032845, 3077.47949387, },     },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.11711771819, 8023.49009169, 8999.38038484, -0.866924842728, -0.00054604994695, 0.194248959188, 12244.2801327, 2770.69890939, },       std::vector<float> {0.123412612098, 8000.44678174, 8999.95198857, -0.907671438072, -0.00055922418604, 0.161063542621, 13181.5784945, 3141.47943724, },      std::vector<float> {0.0986365164392, 18022.863989, 5583.43510088, -1.09373400038, -0.000386416873927, 0.0794612748715, 19622.5836485, 3904.58896198, },       std::vector<float> {0.0957294430732, 16050.2645675, 5141.81993085, -1.10926903188, -0.000387079733727, 0.154381674157, 11075.8791995, 3785.13958834, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.133078973086, 13369.664861, 3986.92965542, -1.05020116376, -0.000425930674108, 0.180759417678, 11322.4938862, 2974.63491572, },       std::vector<float> {0.120396397744, 8152.7686655, 8998.3275061, -1.03848372545, -0.000500073408788, 0.177743271745, 11007.586585, 3240.04686449, },       std::vector<float> {0.107007798101, 8000.01339514, 8999.99963953, -1.16861496034, -0.000438936935876, 0.174211933364, 11339.6991596, 3387.83109316, },      std::vector<float> {0.0755939648782, 17229.0869095, 8941.41103839, -1.25072810359, -0.000356877921067, 0.148163041329, 10000.0001117, 4216.33515221, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.135434609703, 8010.60470833, 8772.23903447, -0.969420092644, -0.000570205858435, 0.177031596083, 11375.6661764, 3243.497176, },       std::vector<float> {0.126204696613, 8005.18723132, 8999.94241936, -0.932166016905, -0.000562213148733, 0.182934851708, 11430.7187803, 3244.34712883, },       std::vector<float> {0.109664472792, 8008.46286864, 8999.97372525, -1.03946122057, -0.0004890697408, 0.181526406655, 11845.1641403, 3289.00484501, },      std::vector<float> {0.0782312148945, 18930.4658362, 8910.05505412, -1.21823234136, -0.000365220204787, 0.147235399004, 11251.9038491, 4125.78725174, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.127502699234, 14133.7374433, 4863.90672938, -0.945666335704, -0.000475218726811, 0.187972620561, 11689.8062165, 3008.94910019, },       std::vector<float> {0.12432551674, 8015.88782958, 8999.95765798, -0.892477796476, -0.000574749345459, 0.186994865149, 11703.7740049, 3188.9750101, },       std::vector<float> {0.112382887571, 8007.33121658, 8999.59607812, -1.04030808288, -0.000500603034919, 0.178770948079, 10785.1745202, 3541.62040032, },      std::vector<float> {0.0971210236055, 8002.80167881, 8999.49681694, -1.11863908948, -0.000449161715706, 0.122515148707, 12297.100983, 4411.20952381, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.134192912248, 14073.3556144, 4401.0952939, -1.08695420076, -0.000435487769759, 0.173668352061, 11190.79127, 3346.86911079, },       std::vector<float> {0.130520188322, 8000.00008413, 8999.19014669, -0.989068619933, -0.000565635554668, 0.174060592116, 11385.9158439, 3487.99602168, },       std::vector<float> {0.111405431775, 8000.11967216, 8998.35388864, -1.14143972645, -0.000479049777155, 0.167983124462, 12418.3262891, 3596.224709, },      std::vector<float> {0.100014165768, 8004.79282789, 8999.79320305, -1.22039787507, -0.000437296750453, 0.116642973298, 12905.1047041, 4738.09041466, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.141326785817, 8464.38591023, 7611.51102491, -0.73221114025, -0.000668828768488, 0.192908385001, 11896.0175036, 2908.18627481, },      std::vector<float> {0.126446120155, 8000.16919453, 8999.99701572, -0.948008499517, -0.000563614454932, 0.181357159923, 13145.2498363, 3039.25259591, },       std::vector<float> {0.105288712833, 8004.92965506, 8998.63701344, -1.07734152394, -0.000472207019855, 0.182576062862, 11225.529737, 3361.21115466, },       std::vector<float> {0.0997506388235, 8004.62529178, 8997.25253071, -1.14704534858, -0.000445254721449, 0.0873952604461, 16977.3049996, 4594.36525182, },    },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.148761614705, 8002.46679267, 6598.39946707, -0.865678305777, -0.000616353335004, 0.189199018013, 10197.01498, 3138.04474946, },       std::vector<float> {0.130922055479, 8000.11624314, 8999.83663056, -0.934531590217, -0.000566462268643, 0.124554116676, 15084.3630212, 3271.17883971, },       std::vector<float> {0.0958659384386, 15251.9723654, 4354.10479286, -1.05030252091, -0.00039712483169, 0.101834972053, 14833.6677189, 3999.63443815, },      std::vector<float> {0.0937893303446, 16595.3854096, 5615.7929728, -1.14490672744, -0.000384230137524, 0.183904708352, 10636.230523, 3568.23246187, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.131602528702, 8000.00015469, 8770.35819439, -0.96330457754, -0.000549005184891, 0.180998017176, 11253.6405072, 3105.99624635, },      std::vector<float> {0.128430586466, 8000.8661145, 8816.09239879, -1.03775860512, -0.000512905500976, 0.174157883944, 11359.8355285, 3147.06133959, },       std::vector<float> {0.108370091986, 8000.85936682, 8999.84630932, -1.08707767994, -0.000462002183561, 0.18066241387, 11053.3811631, 3280.73687601, },       std::vector<float> {0.100334571346, 8000.00755883, 8997.01868562, -1.22303525221, -0.000407212291904, 0.173006862655, 10519.5167621, 3510.94003995, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.141770970851, 8003.70629062, 7378.20243381, -0.90955866704, -0.000596686916859, 0.180427138938, 10000.0000028, 3396.99733183, },      std::vector<float> {0.130717953297, 8040.74450808, 8999.69474195, -0.934967121679, -0.000567849336288, 0.182004225412, 11686.009563, 3167.33686214, },      std::vector<float> {0.115520970951, 8000.35614536, 8999.78513876, -1.05104647573, -0.000490013111421, 0.176569947069, 12116.0559862, 3194.1048823, },       std::vector<float> {0.101230120088, 8004.84469885, 8999.77394118, -1.15726548627, -0.000447176504452, 0.14907358836, 11789.5359885, 4004.31709991, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.130178528767, 13307.7575278, 3871.63979284, -1.08630536828, -0.000423030619677, 0.175342997173, 10599.5826162, 3423.47755666, },      std::vector<float> {0.126293226176, 8030.1956187, 8998.68020323, -0.935226000164, -0.000558629711144, 0.182566106303, 10852.8863687, 3329.81881772, },      std::vector<float> {0.118489092372, 8004.50282162, 8999.48824854, -0.9968644097, -0.00052727921292, 0.179409753969, 11591.8044906, 3328.56967353, },      std::vector<float> {0.10090169258, 8003.58192995, 8998.78224702, -1.16370102774, -0.000440245318906, 0.101050326616, 14705.3417335, 4535.1858464, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.131182756348, 13283.7931741, 4481.92746946, -1.08572464756, -0.000446519125297, 0.171994413513, 10400.6014534, 3551.21871354, },      std::vector<float> {0.118731866722, 15093.8542075, 5042.91063322, -1.15145476787, -0.000406649326906, 0.170523543843, 11529.0747102, 3464.54768777, },      std::vector<float> {0.114081978492, 8000.61527574, 8999.99096077, -1.06894496116, -0.000498088152898, 0.172889740285, 11577.8406454, 3507.11131203, },      std::vector<float> {0.103962529757, 8003.70382839, 8999.99979893, -1.19775113386, -0.000450067069496, 0.137918774326, 11757.496987, 4396.00918808, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.138185982721, 9728.21447947, 7968.60560658, -0.964306613612, -0.00058866457249, 0.150601947605, 13851.5412619, 3216.83166233, },      std::vector<float> {0.132642204356, 8000.3920956, 8618.35479932, -0.960648507362, -0.000567080885539, 0.180566648383, 10605.34521, 3395.1166266, },       std::vector<float> {0.118783190568, 8055.7409042, 8999.03202332, -0.876593877691, -0.000566342004549, 0.0889411839696, 18029.3054766, 3833.44675887, },       std::vector<float> {0.0809493338947, 15942.0068439, 8982.24015837, -1.11748737955, -0.000413494153778, 0.101349427493, 16115.2448145, 4267.63047653, },     },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.160014837825, 11637.7472539, 3227.04732717, -0.877113823516, -0.000512778084169, 0.174975842071, 10000.0000001, 3136.89243418, },       std::vector<float> {0.135002630789, 14263.7632585, 4117.46514424, -1.05041902436, -0.000430879994678, 0.183955092964, 13731.1438955, 2652.04363729, },      std::vector<float> {0.1161515845, 17564.6410925, 8972.34479895, -1.0545964381, -0.00048103154119, 0.104164036737, 18386.2630053, 3226.28665979, },      std::vector<float> {0.110884457632, 8034.60196307, 8999.95396265, -1.00226755883, -0.000507827377824, 0.102432822758, 15545.6894355, 3987.24048646, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.131025083168, 8000.97616916, 7642.3361692, -0.943808384251, -0.000548922123679, 0.18123393248, 10894.0688219, 3113.77176642, },       std::vector<float> {0.126892782611, 8000.01349692, 7939.95023175, -0.892840091508, -0.000552678649495, 0.189114045344, 11293.225362, 2945.96613206, },      std::vector<float> {0.117027124468, 8001.30788535, 8998.58856556, -1.08351796427, -0.000477437795133, 0.141626766975, 13423.479984, 3245.68859269, },       std::vector<float> {0.10585997363, 8000.01815832, 8691.067201, -1.1724806954, -0.000435806252093, 0.1712189328, 10353.8827115, 3583.55475395, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.13708305581, 12777.245396, 4082.8515076, -1.03836411932, -0.000453499395279, 0.172230409426, 10537.0382455, 3386.59527133, },       std::vector<float> {0.133498714222, 8000.00069999, 8659.70788293, -1.02541010463, -0.000547721917973, 0.173791377881, 11234.1185011, 3398.83533445, },      std::vector<float> {0.121425600592, 8000.00046693, 8997.24950943, -1.1216736736, -0.000488225951041, 0.167153399118, 11268.3447492, 3490.58131621, },       std::vector<float> {0.10460890849, 8002.43993485, 8999.86157556, -1.15941979872, -0.0004526579858, 0.165769128501, 11062.6057961, 3813.19865599, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.139106094085, 13122.0026694, 3725.63347401, -1.10114067024, -0.000423867173333, 0.173953406083, 10000.0001974, 3434.37823664, },      std::vector<float> {0.126531725893, 14507.8161651, 4326.81165552, -1.11918223781, -0.000409420696951, 0.174069888691, 11157.4153418, 3343.35301759, },      std::vector<float> {0.118774226467, 8000.02930815, 8999.35213983, -0.988207259224, -0.000525135529987, 0.17594474584, 11581.3866717, 3319.81312518, },      std::vector<float> {0.107466516306, 8000.00213708, 8999.61304298, -1.18208233984, -0.000446686880906, 0.149455689963, 12373.5427625, 3745.97032904, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.132849294677, 13955.796878, 3822.20376769, -1.23839893035, -0.000386451591131, 0.158196834803, 11586.1764537, 3647.86922052, },       std::vector<float> {0.123260629504, 14655.4486524, 4384.5501683, -1.1353508962, -0.000414536799627, 0.167840038312, 10305.5457985, 3827.69116909, },      std::vector<float> {0.108366882008, 15499.9392077, 4063.37450964, -1.27086302041, -0.000353112011308, 0.164117153167, 12541.5531324, 3534.77514495, },      std::vector<float> {0.111159900775, 8001.63009565, 8999.88844992, -1.19950624816, -0.000466618175967, 0.165043095706, 11319.1927454, 3953.51181401, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.135933680283, 13383.853944, 3918.86769874, -1.12782225167, -0.000422508049791, 0.172678961962, 10204.953796, 3589.99701905, },      std::vector<float> {0.125563101758, 8000.2853221, 8898.52267209, -0.917959977121, -0.000561400686827, 0.102437500001, 15286.0760635, 3697.25714068, },      std::vector<float> {0.118218855988, 8038.90300026, 8999.87732044, -0.795184989547, -0.000604351011422, 0.0812670482111, 18585.3396376, 4052.6568213, },       std::vector<float> {0.113501769821, 8021.0418039, 8999.92945616, -1.00669224128, -0.000525329498219, 0.0902204347565, 18317.2192892, 4032.04452947, },    },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.162209835339, 12269.1964149, 2818.2441516, -1.15994364855, -0.000385911224993, 0.164982181086, 13920.5237009, 2399.81981698, },       std::vector<float> {0.131802176775, 8000.00177937, 8999.65587868, -1.03302929388, -0.000548129647287, 0.163510013969, 10918.7360121, 3461.5456228, },       std::vector<float> {0.120220798496, 8013.35803205, 8996.91382929, -0.905750436605, -0.000552884814963, 0.187134502876, 12764.1997562, 2913.77211186, },       std::vector<float> {0.117348536918, 8000.00006311, 8999.38293657, -1.15562932545, -0.000459006301264, 0.0923063702934, 16921.7600284, 3777.56662799, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.149032643437, 8000.04671853, 8069.600485, -0.975349499586, -0.000605242553628, 0.0738924884478, 16741.5098287, 4711.88102418, },      std::vector<float> {0.124000668569, 13729.3025215, 4056.07931719, -1.15571752506, -0.000393372635416, 0.169287019228, 11798.0408571, 3227.60278425, },      std::vector<float> {0.11240325796, 8000.02234195, 8998.33906092, -1.08946632462, -0.000466432611224, 0.17792403591, 13439.4147533, 2810.12369966, },      std::vector<float> {0.109988037313, 8027.08632535, 8999.73912442, -1.22310544021, -0.000431518817829, 0.137641447135, 13070.9432414, 3621.78008111, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.137739272972, 8013.91536277, 7589.32469165, -1.02578307015, -0.000560317024628, 0.133816343053, 10000.0000013, 4269.07263948, },      std::vector<float> {0.113705433179, 14249.9581791, 4304.45351069, -1.08948704864, -0.000406345607001, 0.177410503089, 10215.1517323, 3506.701063, },      std::vector<float> {0.109287141934, 14104.0053883, 4557.52409482, -1.11936071917, -0.000401359171811, 0.172130514531, 10242.0707516, 3590.75606796, },      std::vector<float> {0.113640157155, 8727.50761086, 8999.82959545, -1.17453278299, -0.000466267818104, 0.15706661394, 10000.0000048, 4083.29094678, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.14669166344, 8000.00027055, 8734.6589637, -0.951491125939, -0.000582290778478, 0.178247555534, 11691.5401868, 2899.96610892, },       std::vector<float> {0.137063336238, 8000.17821618, 8216.70041388, -0.854580821186, -0.000611164784074, 0.184335955474, 10000.0000057, 3375.09318936, },       std::vector<float> {0.114094180732, 8004.25161337, 8999.99206437, -1.01071203964, -0.000509244843784, 0.115375962228, 13945.9591619, 3964.79181459, },      std::vector<float> {0.112227315443, 8001.5543865, 8999.98804411, -1.11541857719, -0.000477315922181, 0.166526590934, 11884.6645598, 3562.47131276, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.146390387639, 13904.0402342, 3810.94940558, -1.25138636063, -0.000390775064328, 0.153056381053, 11420.4933627, 3627.14264712, },      std::vector<float> {0.125938895711, 13751.7651846, 4662.80637361, -1.14945723449, -0.000426003242629, 0.164486147227, 11702.5849144, 3588.99095449, },      std::vector<float> {0.125697688416, 8004.83583871, 8999.24027866, -1.1220198331, -0.000527622272295, 0.132329943449, 14905.8840974, 3733.17676939, },       std::vector<float> {0.0976535321389, 16969.3993996, 4479.2995162, -1.27391013041, -0.000342402501428, 0.164968703004, 11028.5764596, 3954.38656161, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.160153737274, 13909.2659507, 3684.59539435, -1.01162766711, -0.000468819788298, 0.173193540932, 11397.4454508, 3202.06612276, },      std::vector<float> {0.140101304846, 8011.43911237, 7466.7534272, -0.97427830417, -0.000575038798433, 0.175444264421, 12799.6022376, 3088.22110236, },       std::vector<float> {0.114373434652, 14062.5717685, 3741.78335486, -1.04486179206, -0.000408601037506, 0.163579367101, 13193.1447752, 2948.04756473, },      std::vector<float> {0.0948050148556, 16914.2430943, 4962.15414406, -1.13458849096, -0.000371472623116, 0.122883565618, 16604.4944199, 3266.16979695, },     },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.172956768745, 9795.14323442, 2131.40522472, -1.4201097499, -0.000298738446652, 0.172957599037, 10000.0000045, 2405.84245526, },       std::vector<float> {0.177221875518, 10699.6880901, 2443.26047115, -1.29215806579, -0.000365413125414, 0.169308839878, 10347.2936135, 2766.80590326, },      std::vector<float> {0.172951306607, 11318.7693555, 2773.06328286, -1.28595987078, -0.000372143604999, 0.0650021332157, 20340.6155381, 2757.64681332, },       std::vector<float> {0.186261291756, 8000.09535785, 3675.56510439, -0.866855792987, -0.000587198928396, 0.0582608464387, 18881.547723, 3549.40029822, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.208068341387, 9163.48247945, 2273.57623185, -0.802928724631, -0.000520965291439, 0.0698396489488, 15630.7336331, 3694.67705804, },      std::vector<float> {0.20123107049, 8358.02073675, 2714.88480417, -0.541021571215, -0.000653079112134, 0.0559108678441, 16619.3961488, 4281.73537838, },       std::vector<float> {0.189634287841, 9805.07934733, 2667.99243894, -0.896104216812, -0.000499346445776, 0.0639161315399, 17068.0505095, 3756.31880629, },      std::vector<float> {0.178497159896, 8000.00002881, 3420.28702495, -0.709302304229, -0.000608807108563, 0.0711210448572, 16181.81878, 3741.33918314, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.202805228709, 9144.34302694, 2535.72202953, -0.848348155912, -0.000536485402499, 0.0537023458912, 17714.3084819, 4157.90791267, },      std::vector<float> {0.201179611069, 9407.90572646, 2458.38070658, -0.706960513121, -0.000566850074972, 0.0640611195366, 15519.2875725, 4273.78864199, },      std::vector<float> {0.192333951373, 8000.32276293, 3669.60513669, -0.530663292802, -0.000721093978265, 0.185680206125, 10497.6470695, 2657.9416539, },      std::vector<float> {0.186096037941, 8000.00110524, 3534.41090722, -0.752777848376, -0.000623706965679, 0.0670702590602, 17092.6390474, 4015.22299044, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.199074042534, 9273.59169882, 2808.42079087, -0.788233088799, -0.000576746337343, 0.0595571114251, 17759.2288835, 4123.50885201, },      std::vector<float> {0.20424078581, 8953.23599329, 2587.4953937, -0.744066027632, -0.000573991694597, 0.0457553517145, 20102.7643153, 4520.34343221, },      std::vector<float> {0.189006726972, 9581.86021886, 2620.66751899, -0.966749046456, -0.00048654172371, 0.0632362308364, 18024.9879267, 4126.40779091, },       std::vector<float> {0.171986129552, 10445.747817, 3044.76554182, -0.937211563437, -0.00049398834476, 0.114458760921, 11339.8096224, 3839.46492867, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.192233857306, 9723.27564399, 2372.84088067, -1.11540537403, -0.000426244551311, 0.0448004848199, 21670.8213629, 3965.95295957, },       std::vector<float> {0.179459943421, 10410.6301278, 2591.24354307, -1.19780617667, -0.000397982069127, 0.0813493855688, 14473.5152659, 3977.6158973, },      std::vector<float> {0.182915313429, 10468.1503553, 2496.40356857, -1.1330974035, -0.000416559401682, 0.0615879686308, 18463.206547, 3974.68319276, },       std::vector<float> {0.164652315751, 10579.0323758, 3085.06403956, -0.968205262063, -0.000479324765219, 0.0614976865373, 19048.5387093, 4255.055133, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.214600103165, 9111.97025951, 2211.72843101, -0.91246724262, -0.000481184814953, 0.214600550876, 10097.6796101, 2030.00406627, },      std::vector<float> {0.183138929766, 8000.65724985, 2835.99173232, -1.06706514481, -0.000453324209336, 0.185603008322, 12715.1227464, 2142.96430783, },      std::vector<float> {0.199405807952, 9528.74401337, 2808.44704997, -0.757640390251, -0.000584815419107, 0.199600216347, 10000.0000184, 2578.21182997, },       std::vector<float> {0.192772542349, 8006.53689563, 3242.88881191, -0.680545832981, -0.000636916806031, 0.109841798664, 12275.1496285, 3376.73785949, },     },
  },
  std::vector< std::vector< std::vector<float> > >{
    std::vector< std::vector<float> > {
      std::vector<float> {0.195991007696, 9123.42607722, 2616.63818852, -0.889432527267, -0.000508029933329, 0.0586332566979, 18946.6216479, 3487.51746373, },      std::vector<float> {0.192481514813, 9447.19118807, 2868.75349815, -0.925630891226, -0.00052384806305, 0.18066680517, 10000.0, 2845.97612343, },       std::vector<float> {0.200298026926, 8000.0222007, 3317.62277368, -0.67988432226, -0.000652916421044, 0.200815814162, 11928.9347414, 2089.32793273, },       std::vector<float> {0.178931561105, 8000.09832572, 3975.68631348, -0.75745187574, -0.000633309535794, 0.197794007941, 10096.1659359, 2699.14485477, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.205573189432, 9287.81247721, 2125.57286256, -0.959872065246, -0.000488318137453, 0.205573968188, 11154.2622928, 2286.67058083, },       std::vector<float> {0.18867727512, 8373.18261239, 3278.0956446, -0.705876187778, -0.000619394293522, 0.0692917036285, 17660.0954301, 3477.34049, },       std::vector<float> {0.181280523363, 8000.00440701, 3398.19459913, -0.539730019921, -0.000661480899476, 0.120712421155, 14328.5134216, 2533.64143722, },       std::vector<float> {0.164364781071, 8000.07353981, 3793.55770814, -0.619979027299, -0.000624497799396, 0.084081308075, 14860.5243431, 3386.73475453, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.19289082098, 9325.90567373, 2622.82938235, -0.895070990728, -0.000513384616417, 0.0621263995899, 16048.8559593, 4401.14345824, },       std::vector<float> {0.19820183473, 9077.04508947, 2507.00895993, -0.719738069352, -0.000554224792784, 0.0744751887718, 14913.1026949, 3595.09818277, },       std::vector<float> {0.176842571895, 10429.7689897, 2602.02526048, -1.08597728837, -0.000420736228199, 0.055706634379, 20453.6016485, 3669.93102202, },      std::vector<float> {0.185589246407, 8000.00000511, 3616.40243853, -0.587097461114, -0.000688412426655, 0.0636699226629, 18020.2011933, 3873.05629919, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.195039569341, 9485.56092016, 2614.5259621, -0.950078788331, -0.000498651882161, 0.0704410455674, 18083.478082, 3253.19220762, },      std::vector<float> {0.199966664885, 9749.54819863, 2411.98182659, -0.888877692871, -0.000513119960986, 0.0824834880097, 16585.317295, 3549.29636741, },       std::vector<float> {0.194061006741, 9258.0080903, 2764.33866561, -0.677360223684, -0.000602698786015, 0.0635151475677, 15679.9522376, 4518.3407946, },      std::vector<float> {0.185872683906, 8103.30374752, 3456.4449166, -0.703592010214, -0.000652045454055, 0.0807796676286, 17455.6226293, 3617.11138943, },     },
    std::vector< std::vector<float> > {
      std::vector<float> {0.186749385958, 9265.72743138, 2667.15517817, -1.04279921641, -0.00046500033099, 0.0717214597369, 15756.7964284, 3969.4321088, },       std::vector<float> {0.187230151023, 10068.3666279, 2449.30925948, -1.07247404427, -0.000441999615405, 0.0586453145825, 18792.1169091, 4132.915378, },       std::vector<float> {0.166597847161, 10723.9946674, 2681.21935679, -0.957185823747, -0.00045982916066, 0.0585747797472, 20416.2872141, 3832.45152268, },       std::vector<float> {0.185406641625, 8000.04764008, 3531.72805714, -0.675591104119, -0.000666420241842, 0.0621628959809, 19071.4450446, 4140.44033414, },    },
    std::vector< std::vector<float> > {
      std::vector<float> {0.203141332793, 9534.44920607, 1976.09459666, -1.0819606568, -0.000406871850494, 0.20314136007, 10711.6586141, 2158.59811087, },      std::vector<float> {0.188088054368, 9444.43278841, 2746.83672845, -0.736825478258, -0.000563323574922, 0.207347670247, 10937.2990654, 2379.59409584, },       std::vector<float> {0.181849010582, 10573.8723059, 2697.74103942, -1.20669969087, -0.000411413818158, 0.111417331006, 10000.000434, 3920.6713506, },      std::vector<float> {0.152043242195, 10957.5330399, 2434.62194443, -1.07171647177, -0.000390103119788, 0.0569729511138, 17394.3665307, 4089.30977898, },     },
  },
};

occupancy_ = {
  std::vector< std::vector< float > >{
    std::vector< float > {0.00432502857987, 0.00408618641554, 0.0042288320441,    },    std::vector< float > {0.012984260229, 0.0121818413544, 0.0125418407991,     },    std::vector< float > {0.0199015470469, 0.0188574073784, 0.0194886869328,    },  std::vector< float > {0.0272852583337, 0.0257152173045, 0.0254862656865,  },    std::vector< float > {0.0393900833506, 0.0373764477594, 0.0375117325535,    },    std::vector< float > {0.03711183064, 0.0396447988618, 0.0404418342344,    },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00268004920923, 0.0030710841648, 0.00306126051205,    },    std::vector< float > {0.00868069429894, 0.00810133327564, 0.00830401776414,     },    std::vector< float > {0.0131397965191, 0.0128904230502, 0.0132777964888,    },  std::vector< float > {0.0188736166979, 0.0179468743679, 0.0184931527379,  },    std::vector< float > {0.0263243112877, 0.024570750685, 0.0255993981379,     },    std::vector< float > {0.0243586227995, 0.02483110561, 0.0250308808828,    },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00248441716301, 0.00229452205758, 0.00228586581809,     },    std::vector< float > {0.00794915436395, 0.00703527600664, 0.00627151148302,     },    std::vector< float > {0.0117016764692, 0.0106032865356, 0.0108068671371,    },  std::vector< float > {0.0161643370594, 0.0148222955169, 0.0148957857241,  },    std::vector< float > {0.0225673407582, 0.0212556045735, 0.0208707649083,    },    std::vector< float > {0.0221210524218, 0.0210094459793, 0.0182866737234,    },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00207159334354, 0.0017927018578, 0.00155325810642,    },    std::vector< float > {0.00628776193858, 0.00521936017559, 0.00492014015714,     },    std::vector< float > {0.00897287558033, 0.00808845706373, 0.00757649954481,     },  std::vector< float > {0.0114279702501, 0.010730302913, 0.0101894206398,     },    std::vector< float > {0.0179680119001, 0.0157118815549, 0.0141135995034,    },    std::vector< float > {0.017000683426, 0.0161339003979, 0.014149892521,    },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00425252330314, 0.00467134384777, 0.00482585918176, 0.00497651404947,     },    std::vector< float > {0.0136926557173, 0.0136313545022, 0.0136644219565, 0.0140641335949,     },    std::vector< float > {0.0199167609175, 0.0204876733991, 0.0200009451511, 0.0208063215926,     },    std::vector< float > {0.0255232170629, 0.0266991619963, 0.028531611169, 0.0282214521241,    },    std::vector< float > {0.0364509565214, 0.0378873104539, 0.04011334186, 0.0400320668761,     },    std::vector< float > {0.0402580629731, 0.0416743753021, 0.0392073593799, 0.0412176061702,     },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00336042987715, 0.00348450485422, 0.00333748571779, 0.00364400084718,     },    std::vector< float > {0.0107712358664, 0.0101032527053, 0.010028199908, 0.0102872497945,    },    std::vector< float > {0.0155427250175, 0.0149599956585, 0.0147041645645, 0.0158904751591,     },    std::vector< float > {0.0209504073386, 0.0203515001345, 0.0209340657215, 0.020879940343,    },    std::vector< float > {0.0286478170039, 0.0288062507953, 0.0279905649358, 0.0291047945099,     },    std::vector< float > {0.031641744386, 0.0311856520034, 0.0271562171665, 0.0300213936589,    },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00232527308606, 0.00231925962977, 0.00268110578684, 0.00252965173522,     },    std::vector< float > {0.00732097372019, 0.00679888521247, 0.00716123699055, 0.00731222026166,     },    std::vector< float > {0.0113918846025, 0.0109565918471, 0.0112290947871, 0.0111127713822,     },    std::vector< float > {0.0150199081723, 0.0150340201268, 0.0147709863052, 0.0160376765373,     },    std::vector< float > {0.0213502222074, 0.0203065073523, 0.0206260382094, 0.0215635534776,     },    std::vector< float > {0.0225539763082, 0.0211554071717, 0.020608791613, 0.0225764467276,    },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00178801395749, 0.00179259449951, 0.00175122332516, 0.00191895916204,     },    std::vector< float > {0.00565148239118, 0.00557517911463, 0.00509805685131, 0.00544184178496,     },    std::vector< float > {0.00762921399056, 0.00742353541109, 0.00817871555962, 0.00896966845841,     },    std::vector< float > {0.00989646616249, 0.010219650502, 0.0103750089678, 0.0111977160373,     },    std::vector< float > {0.0151779071817, 0.0150114058898, 0.0161283334902, 0.0161703132508,     },    std::vector< float > {0.0176516489384, 0.0146226221291, 0.0155858085809, 0.0149349738988,     },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.00117559990936, 0.00117898297192, 0.00133144577543, 0.00114319431574,     },    std::vector< float > {0.00317693271134, 0.00326045932664, 0.00352951721026, 0.00347545941722,     },    std::vector< float > {0.00485556943891, 0.00489968546789, 0.0048593415049, 0.00538967642464,    },    std::vector< float > {0.00600612318591, 0.00635024511376, 0.00700962816743, 0.00731089911418,     },    std::vector< float > {0.00955747613338, 0.0093961760903, 0.0105262207373, 0.0104197996515,    },    std::vector< float > {0.0100430344773, 0.0101429848079, 0.0101390700128, 0.0103767116482,     },  },
  std::vector< std::vector< float > >{
    std::vector< float > {0.000645467111064, 0.000957679509876, 0.000808332873702, 0.000860611520794,     },    std::vector< float > {0.00255679235772, 0.00227962060502, 0.0022149450094, 0.00220888862071,  },    std::vector< float > {0.0032493502212, 0.0033603132174, 0.00385506231833, 0.00365482137724,     },    std::vector< float > {0.00422021243961, 0.00491125610458, 0.00511772930016, 0.00501249189931,     },    std::vector< float > {0.00629328844399, 0.00717930122915, 0.00649101022026, 0.00655850547132,     },    std::vector< float > {0.00709226122132, 0.00682421304085, 0.00795037760975, 0.00748085481559,     },  },
};

  chargeDistributionParameters_puBinEdges_ = { 0, 10, 20, 30, 40, 50 };
  chargeDistributionParameters_zBinEdges_ = { 0, 25, 50, 75 };




  apvBaselineDistributions_tib_ = {};
  for ( auto zBin:chargeDistributionParameters_zBinEdges_ ) {
    apvBaselineDistributions_tib_[0].push_back( TH1F( TString( "TIB1_" + std::to_string( zBin ) ).Data() , TString( "TIB1_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tib_[1].push_back( TH1F( TString( "TIB2_" + std::to_string( zBin ) ).Data() , TString( "TIB2_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tib_[2].push_back( TH1F( TString( "TIB3_" + std::to_string( zBin ) ).Data() , TString( "TIB3_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tib_[3].push_back( TH1F( TString( "TIB4_" + std::to_string( zBin ) ).Data() , TString( "TIB4_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );


    apvBaselineDistributions_tob_[0].push_back( TH1F( TString( "TOB1_" + std::to_string( zBin ) ).Data() , TString( "TOB1_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tob_[1].push_back( TH1F( TString( "TOB2_" + std::to_string( zBin ) ).Data() , TString( "TOB2_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tob_[2].push_back( TH1F( TString( "TOB3_" + std::to_string( zBin ) ).Data() , TString( "TOB3_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tob_[3].push_back( TH1F( TString( "TOB4_" + std::to_string( zBin ) ).Data() , TString( "TOB4_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tob_[4].push_back( TH1F( TString( "TOB5_" + std::to_string( zBin ) ).Data() , TString( "TOB5_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tob_[5].push_back( TH1F( TString( "TOB6_" + std::to_string( zBin ) ).Data() , TString( "TOB6_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );


    apvBaselineDistributions_tid_[0].push_back( TH1F( TString( "TID1_" + std::to_string( zBin ) ).Data() , TString( "TID1_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tid_[1].push_back( TH1F( TString( "TID2_" + std::to_string( zBin ) ).Data() , TString( "TID2_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tid_[2].push_back( TH1F( TString( "TID3_" + std::to_string( zBin ) ).Data() , TString( "TID3_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );

    apvBaselineDistributions_tec_[0].push_back( TH1F( TString( "TEC1_" + std::to_string( zBin ) ).Data() , TString( "TEC1_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[1].push_back( TH1F( TString( "TEC2_" + std::to_string( zBin ) ).Data() , TString( "TEC2_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[2].push_back( TH1F( TString( "TEC3_" + std::to_string( zBin ) ).Data() , TString( "TEC3_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[3].push_back( TH1F( TString( "TEC4_" + std::to_string( zBin ) ).Data() , TString( "TEC4_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[4].push_back( TH1F( TString( "TEC5_" + std::to_string( zBin ) ).Data() , TString( "TEC5_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[5].push_back( TH1F( TString( "TEC6_" + std::to_string( zBin ) ).Data() , TString( "TEC6_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
    apvBaselineDistributions_tec_[6].push_back( TH1F( TString( "TEC7_" + std::to_string( zBin ) ).Data() , TString( "TEC7_" + std::to_string( zBin ) ).Data() , 100, 0, 730 ) );
  }

}

SiStripDigitizerAlgorithm::~SiStripDigitizerAlgorithm(){
}

void
SiStripDigitizerAlgorithm::initializeDetUnit(StripGeomDetUnit const * det, const edm::EventSetup& iSetup){
  edm::ESHandle<SiStripBadStrip> deadChannelHandle;
  iSetup.get<SiStripBadChannelRcd>().get(deadChannelHandle);

  unsigned int detId = det->geographicalId().rawId();
  int numStrips = (det->specificTopology()).nstrips();  

  SiStripBadStrip::Range detBadStripRange = deadChannelHandle->getRange(detId);
  //storing the bad strip of the the module. the module is not removed but just signal put to 0
  std::vector<bool>& badChannels = allBadChannels[detId];
  badChannels.clear();
  badChannels.insert(badChannels.begin(), numStrips, false);
  for(SiStripBadStrip::ContainerIterator it = detBadStripRange.first; it != detBadStripRange.second; ++it) {
    SiStripBadStrip::data fs = deadChannelHandle->decode(*it);
    for(int strip = fs.firstStrip; strip < fs.firstStrip + fs.range; ++strip) {
		badChannels[strip] = true;
	}
  }
  firstChannelsWithSignal[detId] = numStrips;
  lastChannelsWithSignal[detId]= 0;

  //  if(APVSaturationFromHIP){
  //  std::bitset<6> &bs=SiStripTrackerAffectedAPVMap[detId];
  //  if(bs.any())theAffectedAPVvector.push_back(std::make_pair(detId,bs));
  //}
}

void
SiStripDigitizerAlgorithm::initializeEvent(const edm::EventSetup& iSetup) {
  theSiPileUpSignals->reset();
  // This should be clear by after all calls to digitize(), but I might as well make sure
  associationInfoForDetId_.clear();

  APVSaturationProb_ = APVSaturationProbScaling_;  // reset probability
  SiStripTrackerAffectedAPVMap.clear();
  FirstLumiCalc_ = true;
  FirstDigitize_ = true;

  //get gain noise pedestal lorentzAngle from ES handle
  edm::ESHandle<ParticleDataTable> pdt;
  iSetup.getData(pdt);
  setParticleDataTable(&*pdt);
  iSetup.get<SiStripLorentzAngleSimRcd>().get(lorentzAngleName,lorentzAngleHandle);

  for ( unsigned int i = 0; i < apvBaselineDistributions_tib_.size(); ++ i ) {
    for ( auto hist:apvBaselineDistributions_tib_[i] ) hist.Reset();
  }
  for ( unsigned int i = 0; i < apvBaselineDistributions_tob_.size(); ++ i ) {
    for ( auto hist:apvBaselineDistributions_tob_[i] ) hist.Reset();
  }
  for ( unsigned int i = 0; i < apvBaselineDistributions_tid_.size(); ++ i ) {
    for ( auto hist:apvBaselineDistributions_tid_[i] ) hist.Reset();
  }
  for ( unsigned int i = 0; i < apvBaselineDistributions_tec_.size(); ++ i ) {
    for ( auto hist:apvBaselineDistributions_tec_[i] ) hist.Reset();
  }

}

//  Run the algorithm for a given module
//  ------------------------------------

void
SiStripDigitizerAlgorithm::accumulateSimHits(std::vector<PSimHit>::const_iterator inputBegin,
                                             std::vector<PSimHit>::const_iterator inputEnd,
                                             size_t inputBeginGlobalIndex,
					     unsigned int tofBin,
                                             const StripGeomDetUnit* det,
                                             const GlobalVector& bfield,
					     const TrackerTopology *tTopo,
                                             CLHEP::HepRandomEngine* engine) {
  // produce SignalPoints for all SimHits in detector
  unsigned int detID = det->geographicalId().rawId();
  int numStrips = (det->specificTopology()).nstrips();  

  size_t thisFirstChannelWithSignal = numStrips;
  size_t thisLastChannelWithSignal = 0;

  float langle = (lorentzAngleHandle.isValid()) ? lorentzAngleHandle->getLorentzAngle(detID) : 0.;

  std::vector<float> locAmpl(numStrips, 0.);

  // Loop over hits

  uint32_t detId = det->geographicalId().rawId();
  // First: loop on the SimHits
  if(CLHEP::RandFlat::shoot(engine) > inefficiency) {
    AssociationInfoForChannel* pDetIDAssociationInfo; // I only need this if makeDigiSimLinks_ is true...
    if( makeDigiSimLinks_ ) pDetIDAssociationInfo=&(associationInfoForDetId_[detId]); // ...so only search the map if that is the case
    std::vector<float> previousLocalAmplitude; // Only used if makeDigiSimLinks_ is true. Needed to work out the change in amplitude.

    size_t simHitGlobalIndex=inputBeginGlobalIndex; // This needs to stored to create the digi-sim link later
    for (std::vector<PSimHit>::const_iterator simHitIter = inputBegin; simHitIter != inputEnd; ++simHitIter, ++simHitGlobalIndex ) {
      // skip hits not in this detector.
      if((*simHitIter).detUnitId() != detId) {
        continue;
      }
      // check TOF
      if (std::fabs(simHitIter->tof() - cosmicShift - det->surface().toGlobal(simHitIter->localPosition()).mag()/30.) < tofCut && simHitIter->energyLoss()>0) {
        if( makeDigiSimLinks_ ) previousLocalAmplitude=locAmpl; // Not needed except to make the sim link association.
        size_t localFirstChannel = numStrips;
        size_t localLastChannel  = 0;
        // process the hit
        theSiHitDigitizer->processHit(&*simHitIter, *det, bfield, langle, locAmpl, localFirstChannel, localLastChannel, tTopo, engine);
 
        if(thisFirstChannelWithSignal > localFirstChannel) thisFirstChannelWithSignal = localFirstChannel;
        if(thisLastChannelWithSignal < localLastChannel) thisLastChannelWithSignal = localLastChannel;

        if( makeDigiSimLinks_ ) { // No need to do any of this if truth association was turned off in the configuration
          for( size_t stripIndex=0; stripIndex<locAmpl.size(); ++stripIndex ) {
            // Work out the amplitude from this SimHit from the difference of what it was before and what it is now
            float signalFromThisSimHit=locAmpl[stripIndex]-previousLocalAmplitude[stripIndex];
            if( signalFromThisSimHit!=0 ) { // If this SimHit had any contribution I need to record it.
              auto& associationVector=(*pDetIDAssociationInfo)[stripIndex];
              bool addNewEntry=true;
              // Make sure the hit isn't in already. I've seen this a few times, it always seems to happen in pairs so I think
              // it's something to do with the stereo strips.
              for( auto& associationInfo : associationVector ) {
                if( associationInfo.trackID==simHitIter->trackId() && associationInfo.eventID==simHitIter->eventId() ) {
                  // The hit is already in, so add this second contribution and move on
                  associationInfo.contributionToADC+=signalFromThisSimHit;
                  addNewEntry=false;
                  break;
                }
              } // end of loop over associationVector
              // If the hit wasn't already in create a new association info structure.
              if( addNewEntry ) associationVector.push_back( AssociationInfo{ simHitIter->trackId(), simHitIter->eventId(), signalFromThisSimHit, simHitGlobalIndex, tofBin } );
            } // end of "if( signalFromThisSimHit!=0 )"
          } // end of loop over locAmpl strips
        } // end of "if( makeDigiSimLinks_ )"
      } // end of TOF check
    } // end for
  }
  theSiPileUpSignals->add(detID, locAmpl, thisFirstChannelWithSignal, thisLastChannelWithSignal);

  if(firstChannelsWithSignal[detID] > thisFirstChannelWithSignal) firstChannelsWithSignal[detID] = thisFirstChannelWithSignal;
  if(lastChannelsWithSignal[detID] < thisLastChannelWithSignal) lastChannelsWithSignal[detID] = thisLastChannelWithSignal;
}

//============================================================================                
void SiStripDigitizerAlgorithm::calculateInstlumiScale(PileupMixingContent* puInfo){
  //Instlumi scalefactor calculating for dynamic inefficiency                                 

  if (puInfo && FirstLumiCalc_) {

    const std::vector<int>& bunchCrossing = puInfo->getMix_bunchCrossing();
    const std::vector<float>& TrueInteractionList = puInfo->getMix_TrueInteractions();
    const int bunchSpacing = puInfo->getMix_bunchSpacing();                                 

    double RevFreq = 11245.;
    double minBXsec = 70.0E-27;  // use 70mb as an approximation
    double Bunch = 2100.;        // 2016 value
    if (bunchSpacing == 50) Bunch = Bunch/2.;

    int pui = 0, p = 0;
    std::vector<int>::const_iterator pu;
    std::vector<int>::const_iterator pu0 = bunchCrossing.end();

    for (pu=bunchCrossing.begin(); pu!=bunchCrossing.end(); ++pu) {
      if (*pu==0) {
        pu0 = pu;
        p = pui;
      }
      pui++;
    }
    if (pu0!=bunchCrossing.end()) {  // found the in-time interaction
      double Tintr = TrueInteractionList.at(p);
      double instLumi = Bunch*Tintr*RevFreq/minBXsec;
      APVSaturationProb_ = instLumi/6.0E33;      
    }
    FirstLumiCalc_ = false;
  }
}

//============================================================================                

void SiStripDigitizerAlgorithm::calculateAPVBaselines(
              TrackingGeometry::DetContainer detUnits,
              const TrackerTopology *tTopo,
              PileupMixingContent* puInfo
              ) {

    // Mostly duplicating code in calculateInstlumiScale
    // Move to a function
    const std::vector<int>& bunchCrossing = puInfo->getMix_bunchCrossing();
    const std::vector<float>& TrueInteractionList = puInfo->getMix_TrueInteractions();
    int pui = 0, p = 0;
    std::vector<int>::const_iterator pu;
    std::vector<int>::const_iterator pu0 = bunchCrossing.end();
    for (pu=bunchCrossing.begin(); pu!=bunchCrossing.end(); ++pu) {
      if (*pu==0) {
        pu0 = pu;
        p = pui;
      }
      pui++;
    }
    unsigned int nTrueInteractions = 0;
    if (pu0!=bunchCrossing.end()) {  // found the in-time interaction
      nTrueInteractions = TrueInteractionList.at(p);
    }

    unsigned int chargeDistributionParameters_puBin = nTrueInteractions / 10;
    // std::cout << "PU bin : " << nTrueInteractions << " " << nTrueInteractions / 10 << " " << chargeDistributionParameters_puBin << std::endl;

    std::vector<unsigned int> nStrips_tib = { 0, 0, 0, 0 };
    std::vector<unsigned int> nStrips_tob = { 0, 0, 0, 0, 0, 0 };
    std::vector<unsigned int> nStrips_tid = { 0, 0, 0 };
    std::vector<unsigned int> nStrips_tec = { 0, 0, 0, 0, 0, 0, 0 };

    std::vector<unsigned int> nStripsNonZero_tib = { 0, 0, 0, 0 };
    std::vector<unsigned int> nStripsNonZero_tob = { 0, 0, 0, 0, 0, 0 };
    std::vector<unsigned int> nStripsNonZero_tid = { 0, 0, 0 };
    std::vector<unsigned int> nStripsNonZero_tec = { 0, 0, 0, 0, 0, 0, 0 };

    std::vector<float> occupancy_tib = { 0, 0, 0, 0 };
    std::vector<float> occupancy_tob = { 0, 0, 0, 0, 0, 0 };
    std::vector<float> occupancy_tid = { 0, 0, 0 };
    std::vector<float> occupancy_tec = { 0, 0, 0, 0, 0, 0, 0 };

    TH1F h_charge_tib = TH1F("h_charge_tib", "h_charge_tib", 60, 0, 60000);
    TH1F h_charge_tob = TH1F("h_charge_tob", "h_charge_tob", 60, 0, 60000);
    TH1F h_charge_tid = TH1F("h_charge_tid", "h_charge_tid", 60, 0, 60000);
    TH1F h_charge_tec = TH1F("h_charge_tec", "h_charge_tec", 60, 0, 60000);

    // Loop all strips and store total number of strips in each layer, strips with charge/amplitude > X, and store distribution of charges
    for(TrackingGeometry::DetContainer::const_iterator iu = detUnits.begin(); iu != detUnits.end(); iu ++){

      auto sgd = dynamic_cast<StripGeomDetUnit const*>((*iu));
      if (sgd != 0){

        DetId detId( sgd->geographicalId() );
        uint32_t SubDet = detId.subdetId();
        int layer = -1;

        if(SubDet==3) {
          layer = tTopo->tibLayer(detId);
          nStrips_tib[layer-1] += sgd->specificTopology().nstrips();
        }
        else if(SubDet==4){
          layer = tTopo->tidRing(detId);
          nStrips_tid[layer-1] += sgd->specificTopology().nstrips();
        } 
        else if(SubDet==5){
          layer = tTopo->tobLayer(detId);
          nStrips_tob[layer-1] += sgd->specificTopology().nstrips();
        } 
        else if(SubDet==6){
          layer = tTopo->tecRing(detId);
          nStrips_tec[layer-1] += sgd->specificTopology().nstrips();
        }


        const SiPileUpSignals::SignalMapType* theSignal(theSiPileUpSignals->getSignal(sgd->geographicalId().rawId()));  

        if(theSignal) {
          for(const auto& amp : *theSignal) {
            if ( amp.second > apv_minAmplitude ) {
              if(SubDet==3) {
                ++nStripsNonZero_tib[layer-1];
                h_charge_tib.Fill( amp.second );
              }
              else if(SubDet==4){
                ++nStripsNonZero_tid[layer-1];
                h_charge_tid.Fill( amp.second );
              } 
              else if(SubDet==5){
                ++nStripsNonZero_tob[layer-1];
                h_charge_tob.Fill( amp.second );
                // std::cout << "TOB charge : " << amp.second << std::endl;
                // if ( amp.second > 30000 ) std::cout << "----> BIG CHARGE" << std::endl;
              } 
              else if(SubDet==6){
                ++nStripsNonZero_tec[layer-1];
                h_charge_tec.Fill( amp.second );
              } 
            }
          }
        }
      }
    }

    // std::cout << "TOB charge info" << std::endl;
    // std::cout << "Entries, mean, max value : " << h_charge_tob.GetEntries() << " " << h_charge_tob.GetMean() << " " << h_charge_tob.GetBinCenter( h_charge_tob.FindLastBinAbove(0) ) << std::endl;


    // For each layer in each subdetctor, calculate the occupancy
    // Also generate a distribution of the APV baseline for each layer
    // std::cout << "Generating APV baselines for TIB" << std::endl;
    for ( unsigned int i = 0; i < nStrips_tib.size(); ++i ) {
      // std::cout << i << std::endl;
      occupancy_tib[i] = float(nStripsNonZero_tib[i]) / float(nStrips_tib[i]);
      std::vector< float > occupanciesVsZ = occupancy_[i][chargeDistributionParameters_puBin];
      // We know which layer we are in
      // Can get the function describing the charge deposited for different bins in z for the number PU in this event
      // std::vector< std::vector< float > > chargeDistributionParameters.at(i); // = something from config file
      // std::vector< std::vector< float > > chargeDistributionParameters_ = chargeDistributionParameters_[i][chargeDistributionParameters_puBin];
      // Pass functions to generateAPVBasline, get back apv baselines in various bins of z for this layer
      // std::cout << "Going into generateAPVBaseline for TIB" << std::endl;
      generateAPVBaseline( occupanciesVsZ, chargeDistributionParameters_[i][chargeDistributionParameters_puBin], apvBaselineDistributions_tib_[i] );
      // std::cout << "DONE : Going into generateAPVBaseline" << std::endl;
    }

    for ( unsigned int i = 0; i < nStrips_tob.size(); ++i ) {
      occupancy_tob[i] = float(nStripsNonZero_tob[i]) / float(nStrips_tob[i]);
      std::vector< float > occupanciesVsZ = occupancy_[4+i][chargeDistributionParameters_puBin];

      // std::cout << "Going into generateAPVBaseline for TOB" << std::endl;
      generateAPVBaseline( occupanciesVsZ, chargeDistributionParameters_[4+i][chargeDistributionParameters_puBin], apvBaselineDistributions_tob_[i] );
      // generateAPVBaseline( occupancy_tob[i], h_charge_tob, apvBaselineDistributions_tob_[i] );
      // std::cout << "DONE : Going into generateAPVBaseline" << std::endl;

    }

    for ( unsigned int i = 0; i < nStrips_tid.size(); ++i ) {
      occupancy_tid[i] = float(nStripsNonZero_tid[i]) / float(nStrips_tid[i]);
      // generateAPVBaseline( occupancy_tid[i], h_charge_tid, apvBaselineDistributions_tid_[i] );
    }


    for ( unsigned int i = 0; i < nStrips_tec.size(); ++i ) {
      occupancy_tec[i] = float(nStripsNonZero_tec[i]) / float(nStrips_tec[i]);
      // generateAPVBaseline( occupancy_tec[i], h_charge_tec, apvBaselineDistributions_tec_[i] );
    }
}

//============================================================================                

void SiStripDigitizerAlgorithm::generateAPVBaseline(
              std::vector< float > occupancyVsZ,
              std::vector< std::vector<float> > chargeDistributionParameters,
              std::vector< TH1F >& baselineDistributions
              ) {

    // std::cout << "N z bins : " << chargeDistributionParameters.size() << std::endl;
    for ( unsigned int i_zBin = 0; i_zBin < chargeDistributionParameters.size(); ++ i_zBin ) {
      TH1F& baselineDistribution = baselineDistributions[ i_zBin ];
      baselineDistribution.Reset();
      std::vector<float> chargeDistributionParameters_i_zBin = chargeDistributionParameters[ i_zBin ];
      float occupancy = occupancyVsZ[ i_zBin ];
      // If occupancy is zero, just fill the APV baseline with zero and return
      // std::cout << "Generating baselines for zbin : " << i_zBin << " " << occupancy << std::endl;
      // std::cout << "Occupancy : " << occupancy << std::endl;
      if ( occupancy == 0. ) {
        baselineDistribution.Fill(0);
        return;
      }

      // Define PDF for the probability for a charge to be deposited in a previous BX for a given occupancy
      unsigned int maxBXWithoutInteraction = log(0.01)/log(1-occupancy);  // Consider BX where probablitiy of interaction is > 1% of occupancy
      TF1 *f_probBX = new TF1("f_probBX","[0]*(1-[0])^x",0,maxBXWithoutInteraction);
      f_probBX->SetParameter(0,occupancy);

      // PDF for amound of charge deposited on a strip
      // TF1 *f_probCharge = new TF1("f_probCharge","( ( x >= 20000 ) ? [5]*TMath::Landau(x,[6],[7]) : [0]*TMath::Landau(x,[1],[2]) + exp([3]+[4]*x) )", apv_minAmplitude, 65536 * theElectronPerADC);
      TF1 *f_probCharge = new TF1("f_probCharge","( ( x >= 20000 ) ? [5]*TMath::Landau(x,[6],[7]) : [0]*TMath::Landau(x,[1],[2]) + exp([3]+[4]*x) )", apv_minAmplitude, 1000000);
      for ( unsigned int i_chargeDistributionParam = 0; i_chargeDistributionParam < chargeDistributionParameters_i_zBin.size(); ++ i_chargeDistributionParam ){
        f_probCharge->SetParameter( i_chargeDistributionParam, chargeDistributionParameters_i_zBin[ i_chargeDistributionParam ] );
      }
      // f_probCharge->SetParameter(0,2.3E-3);
      // f_probCharge->SetParameter(1,1.4E4);
      // f_probCharge->SetParameter(2,3.8E3);

      // myFunc = r.TF1('myFunc','[0]*TMath::Landau(x,[1],[2])',1000,h_scd.GetXaxis().GetXmax())
      // myFunc.SetParameters(2.3E-3, 1.4E4, 3.8E3 )

      double maxChargePicked = 0;


      // Build up distribution of APV baselines for this given occupancy and charge distribution i.e. repeat process several times and store result
      for ( unsigned int n = 0; n < apv_nBaselineToGenerate; ++n ) {

        float baselineQ = 0;
        float timeSinceInteractionInMicroS = 0;
        // unsigned int totalBX = 0;
        unsigned int totalInteractions = 0;
        unsigned int nInteractionsWithSmalChange = 0;

        // Simulate several previous charge deposits in a particular strip
        // Get BX of the charge deposit (how many BX in the past), and how much charge was deposited
        // Calculate how much of that charge is still on the strip in the current BX (BX == 0 ), by decaying the charge by an exponential
        for ( unsigned int i_interaction = 0; i_interaction < apv_nPreviousInteractionsToSimulate; ++i_interaction ) {
          ++totalInteractions;
          unsigned int BX = f_probBX->GetRandom();
          // float charge = chargeDistribution.GetRandom();
          float charge = f_probCharge->GetRandom();
          // if ( charge > 60000 ) {
          //   std::cout << "Sampled charge : " << charge << std::endl;         
          // }
          if ( charge > maxChargePicked ) maxChargePicked = charge;

          // totalBX += BX;
          timeSinceInteractionInMicroS += float(BX) * 25 / 1000;

          float extraChargeToBaseline = ( charge * exp( -1.0 * timeSinceInteractionInMicroS / apv_decayConstantInMicroS ) );

          // Note if this additional charge has a negligible effect on the APV baseline (because it was very far in the past, or only a small charge was deposited)
          // If this happens a few times, then the APV baseline is stable, and there's no point in simulating more charge deposits
          if ( extraChargeToBaseline / baselineQ < apv_smallChangeThreshold ) ++nInteractionsWithSmalChange;         
          if ( nInteractionsWithSmalChange > apv_smallChangeN ) break;

          baselineQ += extraChargeToBaseline;
        }

        // Convert to V, and store (perhaps the APV baseline should be stored as a charge?)
        float baselineV = baselineQ * apv_mVPerQ * apv_fCPerElectron;
        if ( baselineV > apv_maxResponse ) baselineV = apv_maxResponse;
        baselineDistribution.Fill( baselineV );
      }
      // std::cout << "Maximum charge generated : " << maxChargePicked << std::endl;
      // std::cout << baselineDistribution.GetEntries() << " " << baselineDistribution.GetMean() << std::endl;
  }
}

//============================================================================                


void
SiStripDigitizerAlgorithm::digitize(
			   edm::DetSet<SiStripDigi>& outdigi,
			   edm::DetSet<SiStripRawDigi>& outrawdigi,
         edm::DetSet<SiStripRawDigi>& outStripAmplitudes,
         edm::DetSet<SiStripRawDigi>& outStripAmplitudesPostAPV,
         edm::DetSet<SiStripRawDigi>& outStripAPVBaselines,
			   edm::DetSet<StripDigiSimLink>& outLink,
			   const StripGeomDetUnit *det,
			   edm::ESHandle<SiStripGain> & gainHandle,
			   edm::ESHandle<SiStripThreshold> & thresholdHandle,
			   edm::ESHandle<SiStripNoises> & noiseHandle,
			   edm::ESHandle<SiStripPedestals> & pedestalHandle,
			   std::vector<std::pair<int,std::bitset<6>>> & theAffectedAPVvector,
                           CLHEP::HepRandomEngine* engine,
         const TrackerTopology *tTopo
          ) {
  unsigned int detID = det->geographicalId().rawId();
  int numStrips = (det->specificTopology()).nstrips();  

  // Moved from later (if CommonModeNoise)
  DetId  detId(detID);
  uint32_t SubDet = detId.subdetId();

  // Need z coordinate of detset
  const StripTopology * topol = dynamic_cast<const StripTopology*>(&(det->specificTopology()));
  LocalPoint localPos = topol->localPosition(0);
  GlobalPoint globalPos = det->surface().toGlobal(Local3DPoint(localPos.x(),localPos.y(),localPos.z()));
  float detSet_z = fabs( globalPos.z() );
  // Index in apv baseline distributions
  std::vector< float >::iterator low = std::lower_bound( chargeDistributionParameters_zBinEdges_.begin(), chargeDistributionParameters_zBinEdges_.end(), detSet_z );
  unsigned int detSet_zBin = low - chargeDistributionParameters_zBinEdges_.begin() - 1;
  // std::cout << "detSet_z, bin : " << detSet_z << " " << detSet_zBin << std::endl;
  // std::cout << "zBin : " << detSet_zBin << std::endl;
  // Get the corresponding APV baseline distribution for this subdetector and layer
  TH1F* apvBaselineDistribution = 0;
  int layer = -1;
  if(SubDet==3) {
    layer = tTopo->tibLayer(detId);
    // std::cout << "Layer : " << layer << std::endl;
    apvBaselineDistribution = &apvBaselineDistributions_tib_[layer-1][detSet_zBin];
  }
  else if(SubDet==4){
    layer = tTopo->tidRing(detId);
    apvBaselineDistribution = &apvBaselineDistributions_tid_[layer-1][detSet_zBin];
  } 
  else if(SubDet==5){
    layer = tTopo->tobLayer(detId);
    // std::cout << "Layer : " << layer << std::endl;
    apvBaselineDistribution = &apvBaselineDistributions_tob_[layer-1][detSet_zBin];
  } 
  else if(SubDet==6){
    layer = tTopo->tecRing(detId);
    apvBaselineDistribution = &apvBaselineDistributions_tec_[layer-1][detSet_zBin];
  } 


  const SiPileUpSignals::SignalMapType* theSignal(theSiPileUpSignals->getSignal(detID));  

  std::vector<float> detAmpl(numStrips, 0.);
  if(theSignal) {
    for(const auto& amp : *theSignal) {
      detAmpl[amp.first] = amp.second;
    }
  }

  //removing signal from the dead (and HIP effected) strips
  std::vector<bool>& badChannels = allBadChannels[detID];
  for(int strip =0; strip < numStrips; ++strip) {
    if(badChannels[strip]) {detAmpl[strip] = 0.;}
  }

  // Store SCD, before APV sim
  for(int strip =0; strip < numStrips; ++strip) {
    outStripAmplitudes.push_back(SiStripRawDigi(detAmpl[strip]/theElectronPerADC));;
  }

  // Simulate APV response for each strip
  // std::cout << "Simulating APV response for this detset : " << SubDet << std::endl;
  // std::cout << "APV baseline info : " << apvBaselineDistribution->GetEntries() << " " << apvBaselineDistribution->GetMean() << std::endl;
  if ( SubDet == 3 || SubDet == 5 ) {
    for(int strip =0; strip < numStrips; ++strip) {
      if (detAmpl[strip] > 0 ) {
        // Convert charge from electrons to fC
        double stripCharge = detAmpl[strip]*apv_fCPerElectron;

        // Get APV baseline
        double baselineV = apvBaselineDistribution->GetRandom();
        // Store APV baseline for this strip
        outStripAPVBaselines.push_back(SiStripRawDigi(baselineV));

        // Fitted parameters from G Hall/M Raymond
        double maxResponse = apv_maxResponse;
        double rate = apv_rate;
        double baselineQ = apv_maxResponse;

        // Convert V0 into baseline charge
        if ( baselineV < baselineQ ) {
          baselineQ = - 1.0 * rate * log( 2 * maxResponse / ( baselineV + maxResponse ) - 1);
        }

        // Add charge deposited in this BX
        double newStripCharge = baselineQ + stripCharge;

        // Apply APV response
        double signalV = 2 * maxResponse / ( 1 + exp( -1.0 * newStripCharge / rate) ) - maxResponse;
        double gain = signalV - baselineV;

        // Convert gain (mV) to charge (assuming linear region of APV) and then to electrons
        double outputCharge = gain/apv_mVPerQ;
        double outputChargeInADC = outputCharge / apv_fCPerElectron;

        // Output charge back to original container
        detAmpl[strip] = outputChargeInADC;
      }
    }    
  }
  // std::cout << "DONE : Simulating APV response for this detset" << std::endl;


  // Store SCD, after APV sim
  for(int strip =0; strip < numStrips; ++strip) outStripAmplitudesPostAPV.push_back(SiStripRawDigi(detAmpl[strip]/theElectronPerADC));;



  if(APVSaturationFromHIP){
    //Implementation of the proper charge scaling function. Need consider resaturation effect:
    //The probability map gives  the probability that at least one HIP happened during the last N bunch crossings (cfr APV recovery time).
    //The impact on the charge depends on the clostest HIP occurance (in terms of bunch crossing).
    //The function discribing the APV recovery is therefore the weighted average function which takes into account all possibilities of HIP occurances across the last bx's.

    // do this step here because we now have access to luminosity information
    if(FirstDigitize_) {

      for(std::map<int,float>::iterator iter = mapOfAPVprobabilities.begin(); iter != mapOfAPVprobabilities.end(); ++iter){
	std::bitset<6> bs;
	for(int Napv=0;Napv<6;Napv++){
	  float cursor=CLHEP::RandFlat::shoot(engine);
	  bs[Napv]=cursor < iter->second*APVSaturationProb_ ? true:false;  //APVSaturationProb has been scaled by PU luminosity
	}
	SiStripTrackerAffectedAPVMap[iter->first]=bs;
      }

      NumberOfBxBetweenHIPandEvent=1e3;
      bool HasAtleastOneAffectedAPV=false;
      while(!HasAtleastOneAffectedAPV){
        for(int bx=floor(300.0/25.0);bx>0;bx--){ //Reminder: make these numbers not hard coded!!
          float temp=CLHEP::RandFlat::shoot(engine)<0.5?1:0;
          if(temp==1 && bx<NumberOfBxBetweenHIPandEvent){
            NumberOfBxBetweenHIPandEvent=bx;
            HasAtleastOneAffectedAPV=true;
          }
        }
      }

      FirstDigitize_ = false;
    }

    std::bitset<6> & bs=SiStripTrackerAffectedAPVMap[detID];

    if(bs.any()){
      // store this information so it can be saved to the event later
      theAffectedAPVvector.push_back(std::make_pair(detID,bs));

      if(!PreMixing_) {

    // Here below is the scaling function which describes the evolution of the baseline (i.e. how the charge is suppressed).
    // This must be replaced as soon as we have a proper modeling of the baseline evolution from VR runs
    float Shift=1-NumberOfBxBetweenHIPandEvent/floor(300.0/25.0); //Reminder: make these numbers not hardcoded!! 
    float randomX=CLHEP::RandFlat::shoot(engine);
    float scalingValue=(randomX-Shift)*10.0/7.0-3.0/7.0;

    for(int strip =0; strip < numStrips; ++strip) {
      if(!badChannels[strip] &&  bs[strip/128]==1){
        detAmpl[strip] *=scalingValue>0?scalingValue:0.0;
      }
    }
        }
      }
  }


  SiStripNoises::Range detNoiseRange = noiseHandle->getRange(detID);
  SiStripApvGain::Range detGainRange = gainHandle->getRange(detID);
  SiStripPedestals::Range detPedestalRange = pedestalHandle->getRange(detID);

// -----------------------------------------------------------

  auto& firstChannelWithSignal = firstChannelsWithSignal[detID];
  auto& lastChannelWithSignal = lastChannelsWithSignal[detID];
  auto iAssociationInfoByChannel=associationInfoForDetId_.find(detID); // Use an iterator so that I can easily remove it once finished

  if(zeroSuppression){

    //Adding the strip noise
    //------------------------------------------------------  
    if(noise){ 
                         
      if(SingleStripNoise){
//      std::cout<<"In SSN, detId="<<detID<<std::endl;
        std::vector<float> noiseRMSv; 
        noiseRMSv.clear(); 
        noiseRMSv.insert(noiseRMSv.begin(),numStrips,0.); 
        for(int strip=0; strip< numStrips; ++strip){ 
          if(!badChannels[strip]){
            float gainValue = gainHandle->getStripGain(strip, detGainRange); 
            noiseRMSv[strip] = (noiseHandle->getNoise(strip,detNoiseRange))* theElectronPerADC/gainValue;
            //std::cout<<"<SiStripDigitizerAlgorithm::digitize>: gainValue: "<<gainValue<<"\tnoiseRMSv["<<strip<<"]: "<<noiseRMSv[strip]<<std::endl;
          }
        }
         theSiNoiseAdder->addNoiseVR(detAmpl, noiseRMSv, engine);
      } else {
          int RefStrip = int(numStrips/2.);
          while(RefStrip<numStrips&&badChannels[RefStrip]){ //if the refstrip is bad, I move up to when I don't find it 
            RefStrip++;
          } 
          if(RefStrip<numStrips){
            float RefgainValue = gainHandle->getStripGain(RefStrip, detGainRange);
            float RefnoiseRMS = noiseHandle->getNoise(RefStrip,detNoiseRange) *theElectronPerADC/RefgainValue; 
          
            theSiNoiseAdder->addNoise(detAmpl,firstChannelWithSignal,lastChannelWithSignal,numStrips,RefnoiseRMS, engine);
            //std::cout<<"<SiStripDigitizerAlgorithm::digitize>: RefgainValue: "<<RefgainValue<<"\tRefnoiseRMS: "<<RefnoiseRMS<<std::endl;
          }
      }
    }//if noise

    DigitalVecType digis;
    theSiZeroSuppress->suppress(theSiDigitalConverter->convert(detAmpl, gainHandle, detID), digis, detID,noiseHandle,thresholdHandle);
    // Now do the association to truth. Note that if truth association was turned off in the configuration this map
    // will be empty and the iterator will always equal associationInfoForDetId_.end().
    if( iAssociationInfoByChannel!=associationInfoForDetId_.end() ) { // make sure the readings for this DetID aren't completely from noise
      for( const auto& iDigi : digis ) {
        auto& associationInfoByChannel=iAssociationInfoByChannel->second;
        const std::vector<AssociationInfo>& associationInfo=associationInfoByChannel[iDigi.channel()];

        // Need to find the total from all sim hits, because this might not be the same as the total
        // digitised due to noise or whatever.
        float totalSimADC=0;
        for( const auto& iAssociationInfo : associationInfo ) totalSimADC+=iAssociationInfo.contributionToADC;
        // Now I know that I can loop again and create the links
        for( const auto& iAssociationInfo : associationInfo ) {
          // Note simHitGlobalIndex used to have +1 because TrackerHitAssociator (the only place I can find this value being used)
          // expected counting to start at 1, not 0.  Now changed.
          outLink.push_back( StripDigiSimLink( iDigi.channel(), iAssociationInfo.trackID, iAssociationInfo.simHitGlobalIndex, iAssociationInfo.tofBin, iAssociationInfo.eventID, iAssociationInfo.contributionToADC/totalSimADC ) );
        } // end of loop over associationInfo
      } // end of loop over the digis
    } // end of check that iAssociationInfoByChannel is a valid iterator
    outdigi.data = digis;
  }//if zeroSuppression

  if(!zeroSuppression){
    //if(noise){
      // the constant pedestal offset is needed because
      //   negative adc counts are not allowed in case
      //   Pedestal and CMN subtraction is performed.
      //   The pedestal value read from the conditions
      //   is pedValue and after the pedestal subtraction
      //   the baseline is zero. The Common Mode Noise
      //   is not subtracted from the negative adc counts
      //   channels. Adding pedOffset the baseline is set
      //   to pedOffset after pedestal subtraction and CMN
      //   is subtracted to all the channels since none of
      //   them has negative adc value. The pedOffset is
      //   treated as a constant component in the CMN
      //   estimation and subtracted as CMN.
      
         
		//calculating the charge deposited on each APV and subtracting the shift
		//------------------------------------------------------
		if(BaselineShift){
		   theSiNoiseAdder->addBaselineShift(detAmpl, badChannels);
		}
		
		//Adding the strip noise
		//------------------------------------------------------						 
		if(noise){
		    std::vector<float> noiseRMSv;
			noiseRMSv.clear();
		    noiseRMSv.insert(noiseRMSv.begin(),numStrips,0.);
			
		    if(SingleStripNoise){
			    for(int strip=0; strip< numStrips; ++strip){
			  		if(!badChannels[strip]) noiseRMSv[strip] = (noiseHandle->getNoise(strip,detNoiseRange))* theElectronPerADC;
			  	}
			
	    	} else {
			    int RefStrip = 0; //int(numStrips/2.);
		    	    while(RefStrip<numStrips&&badChannels[RefStrip]){ //if the refstrip is bad, I move up to when I don't find it
					RefStrip++;
				}
				if(RefStrip<numStrips){
					float noiseRMS = noiseHandle->getNoise(RefStrip,detNoiseRange) *theElectronPerADC;
					for(int strip=0; strip< numStrips; ++strip){
			       		if(!badChannels[strip]) noiseRMSv[strip] = noiseRMS;
			  		}
				}
			}
			
                    theSiNoiseAdder->addNoiseVR(detAmpl, noiseRMSv, engine);
		}			
		
		//adding the CMN
		//------------------------------------------------------
        if(CommonModeNoise){
		  float cmnRMS = 0.;
		  if(SubDet==3){
		    cmnRMS = cmnRMStib;
		  }else if(SubDet==4){
		    cmnRMS = cmnRMStid;
		  }else if(SubDet==5){
		    cmnRMS = cmnRMStob;
		  }else if(SubDet==6){
		    cmnRMS = cmnRMStec;
		  }
		  cmnRMS *= theElectronPerADC;
                  theSiNoiseAdder->addCMNoise(detAmpl, cmnRMS, badChannels, engine);
		}
		
        		
		//Adding the pedestals
		//------------------------------------------------------
		
		std::vector<float> vPeds;
		vPeds.clear();
		vPeds.insert(vPeds.begin(),numStrips,0.);
		
		if(RealPedestals){
		    for(int strip=0; strip< numStrips; ++strip){
			   if(!badChannels[strip]) vPeds[strip] = (pedestalHandle->getPed(strip,detPedestalRange)+pedOffset)* theElectronPerADC;
		    }
        } else {
		    for(int strip=0; strip< numStrips; ++strip){
			  if(!badChannels[strip]) vPeds[strip] = pedOffset* theElectronPerADC;
			}
		}
		
		theSiNoiseAdder->addPedestals(detAmpl, vPeds);	
		
		 
	//if(!RealPedestals&&!CommonModeNoise&&!noise&&!BaselineShift&&!APVSaturationFromHIP){
    //  edm::LogWarning("SiStripDigitizer")<<"You are running the digitizer without Noise generation and without applying Zero Suppression. ARE YOU SURE???";
    //}else{							 
    
    DigitalRawVecType rawdigis = theSiDigitalConverter->convertRaw(detAmpl, gainHandle, detID);

    // Now do the association to truth. Note that if truth association was turned off in the configuration this map
    // will be empty and the iterator will always equal associationInfoForDetId_.end().
    if( iAssociationInfoByChannel!=associationInfoForDetId_.end() ) { // make sure the readings for this DetID aren't completely from noise
      // N.B. For the raw digis the channel is inferred from the position in the vector.
      // I'VE NOT TESTED THIS YET!!!!!
      // ToDo Test this properly.
      for( size_t channel=0; channel<rawdigis.size(); ++channel ) {
        auto& associationInfoByChannel=iAssociationInfoByChannel->second;
        const auto iAssociationInfo=associationInfoByChannel.find(channel);
        if( iAssociationInfo==associationInfoByChannel.end() ) continue; // Skip if there is no sim information for this channel (i.e. it's all noise)
        const std::vector<AssociationInfo>& associationInfo=iAssociationInfo->second;

        // Need to find the total from all sim hits, because this might not be the same as the total
        // digitised due to noise or whatever.
        float totalSimADC=0;
        for( const auto& iAssociationInfo : associationInfo ) totalSimADC+=iAssociationInfo.contributionToADC;
        // Now I know that I can loop again and create the links
        for( const auto& iAssociationInfo : associationInfo ) {
          // Note simHitGlobalIndex used to have +1 because TrackerHitAssociator (the only place I can find this value being used)
          // expected counting to start at 1, not 0.  Now changed.
          outLink.push_back( StripDigiSimLink( channel, iAssociationInfo.trackID, iAssociationInfo.simHitGlobalIndex, iAssociationInfo.tofBin, iAssociationInfo.eventID, iAssociationInfo.contributionToADC/totalSimADC ) );
        } // end of loop over associationInfo
      } // end of loop over the digis
    } // end of check that iAssociationInfoByChannel is a valid iterator

    outrawdigi.data = rawdigis;
	
	//}
  }

  // Now that I've finished with this entry in the map of associations, I can remove it.
  // Note that there might not be an association if the ADC reading is from noise in which
  // case associationIsValid will be false.
  if( iAssociationInfoByChannel!=associationInfoForDetId_.end() ) associationInfoForDetId_.erase(iAssociationInfoByChannel);
}
